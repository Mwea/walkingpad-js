{
  "version": 3,
  "sources": ["../src/index.ts", "../../web-ble-kit/node_modules/retry/lib/retry_operation.js", "../../web-ble-kit/node_modules/retry/lib/retry.js", "../../web-ble-kit/node_modules/retry/index.js", "../../web-ble-kit/src/errors/errors.ts", "../../web-ble-kit/src/state/event-emitter.ts", "../../web-ble-kit/src/utils/storage.ts", "../../web-ble-kit/src/adapter/web-bluetooth.ts", "../../web-ble-kit/src/async/poll-manager.ts", "../../web-ble-kit/node_modules/p-retry/index.js", "../../web-ble-kit/node_modules/is-network-error/index.js", "../../web-ble-kit/src/ble/transport.ts", "../../web-ble-kit/src/async/retry.ts", "../../web-ble-kit/src/ble/connection-pool.ts", "../../web-ble-kit/src/ble/operation-queue.ts", "../../web-ble-kit/src/state/state-machine.ts", "../../web-ble-kit/src/utils/buffer.ts", "../src/constants.ts", "../src/logger.ts", "../src/errors.ts", "../src/types.ts", "../src/protocol-ftms.ts", "../src/protocol-standard.ts", "../src/protocol-factory.ts", "../src/transport.ts", "../src/manager.ts", "../src/throttle.ts"],
  "sourcesContent": ["/**\n * WalkingPad BLE - TypeScript library for controlling WalkingPad treadmills over Web Bluetooth.\n *\n * @packageDocumentation\n *\n * @example Quick Start\n * ```typescript\n * import { getWalkingPadBLE } from 'walkingpad-ble';\n *\n * const manager = getWalkingPadBLE();\n * await manager.connect();\n *\n * manager.events.on('state', (state) => {\n *   console.log(`Speed: ${state.speed} km/h`);\n * });\n *\n * await manager.start();\n * await manager.setSpeed(3.5);\n * ```\n *\n * @example Custom Adapter\n * ```typescript\n * import { createManager, createWalkingPadAdapter } from 'walkingpad-ble';\n *\n * const adapter = createWalkingPadAdapter({ connectionTimeoutMs: 30000 });\n * const manager = createManager(adapter);\n * await manager.connect();\n * ```\n */\n\nimport {\n  createWebBluetoothAdapter,\n  type WebBluetoothAdapterOptions,\n} from 'web-ble-kit';\nimport {\n  DEFAULT_NAME_PREFIXES,\n  GATT_FTMS_SERVICE,\n  GATT_STANDARD_SERVICE_FE00,\n  GATT_STANDARD_SERVICE_FFF0,\n  toFullUuid,\n} from './constants';\nimport { resetLogger } from './logger';\nimport { createManager, type WalkingPadBLEManager } from './manager';\n\n// Lazy singleton - only created when first accessed\n// This avoids throwing in environments without Web Bluetooth (Node.js, SSR)\nlet defaultInstance: WalkingPadBLEManager | null = null;\n\n/**\n * Creates a pre-configured Bluetooth adapter for WalkingPad devices.\n *\n * @param options - Optional adapter configuration (timeouts, storage, etc.)\n * @returns A configured BLE adapter for WalkingPad devices\n */\nexport function createWalkingPadAdapter(\n  options: WebBluetoothAdapterOptions = {},\n) {\n  return createWebBluetoothAdapter({\n    namePrefixes: DEFAULT_NAME_PREFIXES,\n    optionalServices: [\n      toFullUuid(GATT_FTMS_SERVICE),\n      toFullUuid(GATT_STANDARD_SERVICE_FE00),\n      toFullUuid(GATT_STANDARD_SERVICE_FFF0),\n    ],\n    ...options,\n  });\n}\n\n/**\n * Gets the default WalkingPadBLE singleton instance.\n * Creates the instance lazily on first access using the Web Bluetooth adapter.\n *\n * @returns The default manager instance\n * @throws Error if Web Bluetooth is not available\n *\n * @example\n * ```typescript\n * const manager = getWalkingPadBLE();\n * await manager.connect();\n * ```\n */\nexport function getWalkingPadBLE(): WalkingPadBLEManager {\n  if (!defaultInstance) {\n    defaultInstance = createManager(createWalkingPadAdapter());\n  }\n  return defaultInstance;\n}\n\n// ============================================================================\n// ESSENTIAL TYPES - What most users need\n// ============================================================================\n\n/** The manager interface for controlling WalkingPad treadmills */\nexport type { WalkingPadBLEManager } from './manager';\n/** Treadmill state (speed, distance, time, steps, etc.) */\n/** Options for connect() and reconnect() */\nexport type {\n  ConnectionState,\n  ConnectOptions,\n  ReconnectOptions,\n  WalkingPadState,\n} from './types';\n\n// ============================================================================\n// ERRORS - For error handling\n// ============================================================================\n\nexport {\n  NotConnectedError,\n  SpeedOutOfRangeError,\n  TimeoutError,\n} from './errors';\nexport { ConnectionAbortedError } from './manager';\n\n// ============================================================================\n// ADVANCED - For power users who need custom configuration\n// ============================================================================\n\n/**\n * Creates a manager with a custom adapter and configuration.\n * Use this when you need control over timeouts, logging, or storage.\n *\n * @example Custom timeouts\n * ```typescript\n * const adapter = createWalkingPadAdapter({ connectionTimeoutMs: 30000 });\n * const manager = createManager(adapter, { writeTimeoutMs: 5000 });\n * ```\n */\nexport { createManager };\nexport type { CreateManagerOptions } from './manager';\n\n/** Options for configuring the WalkingPad Bluetooth adapter */\nexport type { WebBluetoothAdapterOptions as AdapterOptions } from 'web-ble-kit';\n\n// ============================================================================\n// CONFIGURATION - For custom logging and storage\n// ============================================================================\n\n/** Custom logger interface */\nexport type { Logger } from './logger';\nexport { enableDebugLogging, resetLogger, setLogger } from './logger';\n\n/** Storage interface for persisting device info (used for auto-reconnect) */\nexport type { DeviceStorage } from 'web-ble-kit';\n/** Storage factory functions */\nexport {\n  createLocalStorage,\n  createMemoryStorage,\n  createNoOpStorage,\n  createSessionStorage,\n} from 'web-ble-kit';\n\n/**\n * Rate limiting utilities for high-frequency UI interactions.\n * Use createThrottledSetSpeed to safely connect a slider to setSpeed.\n */\nexport {\n  createThrottledSetSpeed,\n  type ThrottledSetSpeedOptions,\n} from './throttle';\n\n// ============================================================================\n// TESTING - For test isolation\n// ============================================================================\n\n/**\n * Resets all singleton state. **For testing only.**\n * Clears the default manager instance and resets the logger.\n * This allows tests to run in isolation without state pollution.\n *\n * @example\n * ```typescript\n * afterEach(() => {\n *   resetForTesting();\n * });\n * ```\n */\nexport function resetForTesting(): void {\n  defaultInstance = null;\n  resetLogger();\n}\n", "function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "/**\n * Custom error class for timeout operations.\n *\n * Note: The underlying BLE operation may still complete in the background\n * after a timeout is thrown. The Web Bluetooth API does not support true\n * operation cancellation.\n */\nexport class TimeoutError extends Error {\n\t/**\n\t * Whether the underlying operation may still complete in the background.\n\t * Always true for BLE operations since they cannot be cancelled.\n\t */\n\treadonly operationMayComplete: boolean = true;\n\n\tconstructor(\n\t\tpublic readonly operation: string,\n\t\tpublic readonly timeout: number,\n\t) {\n\t\tsuper(`${operation} timed out after ${timeout}ms`);\n\t\tthis.name = \"TimeoutError\";\n\t}\n}\n\n/**\n * Error thrown when an operation is aborted via AbortSignal.\n */\nexport class AbortError extends Error {\n\tconstructor(message = \"Operation aborted\") {\n\t\tsuper(message);\n\t\tthis.name = \"AbortError\";\n\t}\n}\n\n/**\n * Throws an AbortError if the given signal is aborted.\n * Use this at the start of async operations to fail fast on abort.\n *\n * @example\n * ```typescript\n * async function myOperation(signal?: AbortSignal) {\n *   throwIfAborted(signal);\n *   // ... perform operation\n * }\n * ```\n *\n * @param signal - The AbortSignal to check\n * @throws {AbortError} If the signal is aborted\n */\nexport function throwIfAborted(signal?: AbortSignal): void {\n\tif (signal?.aborted) {\n\t\tconst reason = signal.reason;\n\t\tconst message =\n\t\t\treason instanceof Error\n\t\t\t\t? reason.message\n\t\t\t\t: typeof reason === \"string\"\n\t\t\t\t\t? reason\n\t\t\t\t\t: \"Operation aborted\";\n\t\tthrow new AbortError(message);\n\t}\n}\n\n/**\n * Races a promise against an AbortSignal, rejecting with AbortError if aborted.\n *\n * Note: This does NOT cancel the underlying promise - it continues running\n * in the background. This is a fundamental limitation of JavaScript promises\n * and the Web Bluetooth API.\n *\n * @example\n * ```typescript\n * const controller = new AbortController();\n * setTimeout(() => controller.abort(), 5000);\n *\n * try {\n *   const result = await raceWithAbort(\n *     slowBleOperation(),\n *     controller.signal,\n *   );\n * } catch (e) {\n *   if (e instanceof AbortError) {\n *     console.log('Operation was aborted');\n *   }\n * }\n * ```\n *\n * @param promise - The promise to race\n * @param signal - The AbortSignal to race against\n * @returns Promise that resolves/rejects with the original promise, or rejects with AbortError\n */\nexport function raceWithAbort<T>(\n\tpromise: Promise<T>,\n\tsignal?: AbortSignal,\n): Promise<T> {\n\tif (!signal) return promise;\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst abortHandler = () => {\n\t\t\tconst reason = signal.reason;\n\t\t\tconst message =\n\t\t\t\treason instanceof Error\n\t\t\t\t\t? reason.message\n\t\t\t\t\t: typeof reason === \"string\"\n\t\t\t\t\t\t? reason\n\t\t\t\t\t\t: \"Operation aborted\";\n\t\t\treject(new AbortError(message));\n\t\t};\n\n\t\t// Check if already aborted\n\t\tif (signal.aborted) {\n\t\t\tabortHandler();\n\t\t\treturn;\n\t\t}\n\n\t\tsignal.addEventListener(\"abort\", abortHandler, { once: true });\n\n\t\tpromise\n\t\t\t.then(resolve)\n\t\t\t.catch(reject)\n\t\t\t.finally(() => signal.removeEventListener(\"abort\", abortHandler));\n\t});\n}\n\n/**\n * Error thrown when attempting an operation that requires a connection\n * but the device is not connected.\n */\nexport class NotConnectedError extends Error {\n\tconstructor() {\n\t\tsuper(\"Not connected to device\");\n\t\tthis.name = \"NotConnectedError\";\n\t}\n}\n\n/**\n * Normalizes any thrown value into an Error instance.\n * Ensures consistent error handling throughout the codebase.\n */\nexport function normalizeError(e: unknown): Error {\n\tif (e instanceof Error) {\n\t\treturn e;\n\t}\n\n\tif (e === null) {\n\t\treturn new Error(\"null\");\n\t}\n\n\tif (e === undefined) {\n\t\treturn new Error(\"undefined\");\n\t}\n\n\tif (typeof e === \"string\") {\n\t\treturn new Error(e);\n\t}\n\n\tif (typeof e === \"object\") {\n\t\ttry {\n\t\t\treturn new Error(JSON.stringify(e));\n\t\t} catch {\n\t\t\t// Circular reference or other JSON error\n\t\t\treturn new Error(String(e));\n\t\t}\n\t}\n\n\treturn new Error(String(e));\n}\n\n/**\n * Wraps a promise with a timeout.\n * If the promise doesn't resolve/reject within the specified time,\n * rejects with a TimeoutError.\n *\n * **Important:** This does NOT cancel the underlying operation.\n * The original promise continues running in the background even after\n * timeout. For BLE operations, this means a write may still complete\n * after the timeout rejects. Callers should handle this if needed\n * (e.g., by checking connection state before processing results).\n *\n * @param promise - The promise to wrap with a timeout\n * @param ms - Timeout duration in milliseconds\n * @param label - Descriptive label for the operation (used in error message)\n * @returns A promise that rejects with TimeoutError if the timeout expires first\n * @throws {TimeoutError} If the operation times out\n */\nexport function withTimeout<T>(\n\tpromise: Promise<T>,\n\tms: number,\n\tlabel: string,\n): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst timeoutId = setTimeout(() => {\n\t\t\treject(new TimeoutError(label, ms));\n\t\t}, ms);\n\n\t\tpromise\n\t\t\t.then((value) => {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\tresolve(value);\n\t\t\t})\n\t\t\t.catch((error: unknown) => {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\treject(error);\n\t\t\t});\n\t});\n}\n", "export type EventMap = { [key: string]: unknown };\n\n/**\n * An EventTarget with explicit cleanup capabilities.\n * Use dispose() to clean up all internal state and unsubscribe from the underlying emitter.\n */\nexport interface CleanableEventTarget extends EventTarget {\n\t/**\n\t * Disposes of all internal resources, unsubscribes from the emitter,\n\t * and clears all tracked listeners. After calling dispose(), the target\n\t * should not be used.\n\t */\n\tdispose(): void;\n}\n\nexport interface TypedEventEmitter<T extends EventMap> {\n\ton<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void;\n\tonce<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void;\n\toff<K extends keyof T>(event: K, callback: (data: T[K]) => void): void;\n\tremoveAllListeners<K extends keyof T>(event?: K): void;\n\temit<K extends keyof T>(event: K, data: T[K]): void;\n\tlistenerCount<K extends keyof T>(event: K): number;\n}\n\nexport function createEventEmitter<T extends EventMap>(): TypedEventEmitter<T> {\n\tconst listeners = new Map<keyof T, Set<(data: unknown) => void>>();\n\tconst onceWrappers = new Map<\n\t\t(data: unknown) => void,\n\t\t(data: unknown) => void\n\t>();\n\n\tfunction getListenerSet<K extends keyof T>(\n\t\tevent: K,\n\t): Set<(data: unknown) => void> {\n\t\tlet set = listeners.get(event);\n\t\tif (!set) {\n\t\t\tset = new Set();\n\t\t\tlisteners.set(event, set);\n\t\t}\n\t\treturn set;\n\t}\n\n\tfunction on<K extends keyof T>(\n\t\tevent: K,\n\t\tcallback: (data: T[K]) => void,\n\t): () => void {\n\t\tconst set = getListenerSet(event);\n\t\tset.add(callback as (data: unknown) => void);\n\t\treturn () => off(event, callback);\n\t}\n\n\tfunction once<K extends keyof T>(\n\t\tevent: K,\n\t\tcallback: (data: T[K]) => void,\n\t): () => void {\n\t\tconst wrapper = ((data: T[K]) => {\n\t\t\t// Remove mapping when wrapper executes\n\t\t\tonceWrappers.delete(callback as (data: unknown) => void);\n\t\t\toff(event, wrapper as (data: T[K]) => void);\n\t\t\tcallback(data);\n\t\t}) as (data: T[K]) => void;\n\n\t\tonceWrappers.set(\n\t\t\tcallback as (data: unknown) => void,\n\t\t\twrapper as (data: unknown) => void,\n\t\t);\n\n\t\tconst set = getListenerSet(event);\n\t\tset.add(wrapper as (data: unknown) => void);\n\t\treturn () => off(event, callback);\n\t}\n\n\tfunction off<K extends keyof T>(\n\t\tevent: K,\n\t\tcallback: (data: T[K]) => void,\n\t): void {\n\t\tconst set = listeners.get(event);\n\t\tif (set) {\n\t\t\tconst wrapper = onceWrappers.get(callback as (data: unknown) => void);\n\t\t\tif (wrapper) {\n\t\t\t\tset.delete(wrapper);\n\t\t\t\tonceWrappers.delete(callback as (data: unknown) => void);\n\t\t\t} else {\n\t\t\t\tset.delete(callback as (data: unknown) => void);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction removeAllListeners<K extends keyof T>(event?: K): void {\n\t\tif (event !== undefined) {\n\t\t\t// Fix BUG-001: Clean up onceWrappers for this event's callbacks\n\t\t\tconst set = listeners.get(event);\n\t\t\tif (set) {\n\t\t\t\tfor (const cb of set) {\n\t\t\t\t\t// Find and remove wrapper mapping where this cb is the wrapper\n\t\t\t\t\tfor (const [original, wrapper] of onceWrappers) {\n\t\t\t\t\t\tif (wrapper === cb) {\n\t\t\t\t\t\t\tonceWrappers.delete(original);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisteners.delete(event);\n\t\t} else {\n\t\t\tlisteners.clear();\n\t\t\t// Fix F-016: Clear all once wrapper mappings to prevent memory leak\n\t\t\tonceWrappers.clear();\n\t\t}\n\t}\n\n\tfunction emit<K extends keyof T>(event: K, data: T[K]): void {\n\t\tconst set = listeners.get(event);\n\t\tif (set) {\n\t\t\t// Fix BUG-002: Copy set before iteration to prevent issues when\n\t\t\t// listeners are added/removed during emit (consistent with Node.js EventEmitter)\n\t\t\tconst callbacks = [...set];\n\t\t\tfor (const cb of callbacks) {\n\t\t\t\ttry {\n\t\t\t\t\tcb(data);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\"[web-ble-kit:event-emitter] Listener threw an error:\",\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction listenerCount<K extends keyof T>(event: K): number {\n\t\tconst set = listeners.get(event);\n\t\treturn set ? set.size : 0;\n\t}\n\n\treturn {\n\t\ton,\n\t\tonce,\n\t\toff,\n\t\tremoveAllListeners,\n\t\temit,\n\t\tlistenerCount,\n\t};\n}\n\n/**\n * Adapts a TypedEventEmitter to an EventTarget for browser integration.\n * Allows using addEventListener/removeEventListener with the emitter.\n * Properly tracks listener references and unsubscribes from emitter when\n * the last listener for an event type is removed.\n *\n * @returns A CleanableEventTarget that can be disposed to release all resources.\n */\nexport function toEventTarget<T extends EventMap>(\n\temitter: TypedEventEmitter<T>,\n): CleanableEventTarget {\n\tconst target = new EventTarget();\n\tconst subscriptions = new Map<keyof T, () => void>();\n\t// Track actual listener references per event type to handle deduplication correctly\n\tconst trackedListeners = new Map<\n\t\tkeyof T,\n\t\tSet<EventListenerOrEventListenerObject>\n\t>();\n\tconst onceWrappers = new Map<\n\t\tEventListenerOrEventListenerObject,\n\t\tEventListener\n\t>();\n\n\t// Proxy addEventListener to subscribe to the emitter\n\tconst originalAddEventListener = target.addEventListener.bind(target);\n\tconst originalRemoveEventListener = target.removeEventListener.bind(target);\n\n\t/**\n\t * Helper to remove a listener from our tracking and clean up emitter subscription\n\t */\n\tfunction removeFromTracking(\n\t\teventKey: keyof T,\n\t\tlistener: EventListenerOrEventListenerObject,\n\t): void {\n\t\tconst listeners = trackedListeners.get(eventKey);\n\t\tif (listeners?.has(listener)) {\n\t\t\tlisteners.delete(listener);\n\n\t\t\t// Clean up once wrapper if exists\n\t\t\tonceWrappers.delete(listener);\n\n\t\t\t// Unsubscribe from emitter when last listener is removed\n\t\t\tif (listeners.size === 0) {\n\t\t\t\tconst unsubscribe = subscriptions.get(eventKey);\n\t\t\t\tif (unsubscribe) {\n\t\t\t\t\tunsubscribe();\n\t\t\t\t\tsubscriptions.delete(eventKey);\n\t\t\t\t}\n\t\t\t\t// Clean up empty Set to prevent memory leak\n\t\t\t\ttrackedListeners.delete(eventKey);\n\t\t\t}\n\t\t}\n\t}\n\n\ttarget.addEventListener = (\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject | null,\n\t\toptions?: boolean | AddEventListenerOptions,\n\t) => {\n\t\tif (listener === null) {\n\t\t\treturn; // EventTarget ignores null listeners\n\t\t}\n\n\t\tconst eventKey = type as keyof T;\n\t\tconst isOnce = typeof options === \"object\" && options?.once === true;\n\n\t\tlet listeners = trackedListeners.get(eventKey);\n\t\tif (!listeners) {\n\t\t\tlisteners = new Set();\n\t\t\ttrackedListeners.set(eventKey, listeners);\n\t\t}\n\n\t\t// Check if this exact listener was already added (EventTarget deduplicates)\n\t\tconst wasAlreadyAdded = listeners.has(listener);\n\n\t\t// Subscribe to emitter if this is the first listener for this event\n\t\tif (listeners.size === 0) {\n\t\t\tconst unsubscribe = emitter.on(eventKey, (data) => {\n\t\t\t\ttarget.dispatchEvent(new CustomEvent(type, { detail: data }));\n\t\t\t});\n\t\t\tsubscriptions.set(eventKey, unsubscribe);\n\t\t}\n\n\t\t// Only track if not already tracked (mirrors EventTarget deduplication)\n\t\tif (!wasAlreadyAdded) {\n\t\t\tlisteners.add(listener);\n\n\t\t\tif (isOnce) {\n\t\t\t\tconst wrappedListener: EventListener = (_e: Event) => {\n\t\t\t\t\t// Clean up our tracking AFTER the event fires\n\t\t\t\t\t// The native EventTarget removes the listener automatically,\n\t\t\t\t\t// but we need to update our tracking\n\t\t\t\t\tremoveFromTracking(eventKey, listener);\n\t\t\t\t};\n\t\t\t\tonceWrappers.set(listener, wrappedListener);\n\t\t\t\t// Add the wrapper as a separate once listener to handle cleanup\n\t\t\t\toriginalAddEventListener(type, wrappedListener, { once: true });\n\t\t\t}\n\t\t}\n\n\t\toriginalAddEventListener(type, listener, options);\n\t};\n\n\ttarget.removeEventListener = (\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject | null,\n\t\toptions?: boolean | EventListenerOptions,\n\t) => {\n\t\tif (listener === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst eventKey = type as keyof T;\n\n\t\t// Also remove the once wrapper if it exists\n\t\tconst wrapper = onceWrappers.get(listener);\n\t\tif (wrapper) {\n\t\t\toriginalRemoveEventListener(type, wrapper, options);\n\t\t}\n\n\t\toriginalRemoveEventListener(type, listener, options);\n\t\tremoveFromTracking(eventKey, listener);\n\t};\n\n\t/**\n\t * Disposes of all internal resources and unsubscribes from the emitter.\n\t */\n\tfunction dispose(): void {\n\t\t// Unsubscribe all emitter subscriptions\n\t\tfor (const unsubscribe of subscriptions.values()) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tsubscriptions.clear();\n\t\ttrackedListeners.clear();\n\t\tonceWrappers.clear();\n\t}\n\n\t// Return the target with dispose method attached\n\treturn Object.assign(target, { dispose }) as CleanableEventTarget;\n}\n", "import type { DeviceStorage } from \"../types\";\n\nexport type { DeviceStorage } from \"../types\";\n\nconst DEFAULT_STORAGE_KEY = \"web-ble-kit-device-id\";\n\nexport interface StorageOptions {\n\t/** Storage key to use. Defaults to 'web-ble-kit-device-id' */\n\tkey?: string;\n}\n\nfunction createWebStorage(\n\tstorage: Storage,\n\tname: string,\n\toptions: StorageOptions = {},\n): DeviceStorage {\n\tconst key = options.key ?? DEFAULT_STORAGE_KEY;\n\n\treturn {\n\t\tget(): string | null {\n\t\t\ttry {\n\t\t\t\treturn storage.getItem(key);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[web-ble-kit] Could not read device ID from ${name}:`,\n\t\t\t\t\te instanceof Error ? e.message : String(e),\n\t\t\t\t);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\t\tset(deviceId: string): void {\n\t\t\ttry {\n\t\t\t\tstorage.setItem(key, deviceId);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[web-ble-kit] Could not save device ID to ${name}:`,\n\t\t\t\t\te instanceof Error ? e.message : String(e),\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\n\t\tremove(): void {\n\t\t\ttry {\n\t\t\t\tstorage.removeItem(key);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[web-ble-kit] Could not clear device ID from ${name}:`,\n\t\t\t\t\te instanceof Error ? e.message : String(e),\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t};\n}\n\n/**\n * Creates a DeviceStorage backed by localStorage.\n *\n * @security **Same-Origin Access**: Device IDs stored in localStorage are accessible\n * to any JavaScript running on the same origin. Consider security implications:\n * - XSS attacks could extract stored device IDs\n * - Other scripts on the same origin can read/modify values\n * - Data persists across browser sessions\n *\n * For sensitive applications, consider using `createNoOpStorage()` to disable\n * persistence, `createSessionStorage()` for session-only storage, or implement\n * custom encrypted storage.\n *\n * @param options - Storage configuration options\n * @returns A DeviceStorage implementation using localStorage\n * @throws Error if localStorage is not available\n */\nexport function createLocalStorage(\n\toptions: StorageOptions = {},\n): DeviceStorage {\n\tif (typeof localStorage === \"undefined\") {\n\t\tthrow new Error(\"localStorage is not available in this environment\");\n\t}\n\treturn createWebStorage(localStorage, \"localStorage\", options);\n}\n\nexport function createSessionStorage(\n\toptions: StorageOptions = {},\n): DeviceStorage {\n\tif (typeof sessionStorage === \"undefined\") {\n\t\tthrow new Error(\"sessionStorage is not available in this environment\");\n\t}\n\treturn createWebStorage(sessionStorage, \"sessionStorage\", options);\n}\n\nexport function createMemoryStorage(): DeviceStorage {\n\tlet storedDeviceId: string | null = null;\n\n\treturn {\n\t\tget(): string | null {\n\t\t\treturn storedDeviceId;\n\t\t},\n\n\t\tset(deviceId: string): void {\n\t\t\tstoredDeviceId = deviceId;\n\t\t},\n\n\t\tremove(): void {\n\t\t\tstoredDeviceId = null;\n\t\t},\n\t};\n}\n\nexport function createNoOpStorage(): DeviceStorage {\n\treturn {\n\t\tget(): string | null {\n\t\t\treturn null;\n\t\t},\n\n\t\tset(): void {},\n\n\t\tremove(): void {},\n\t};\n}\n\nlet defaultStorage: DeviceStorage | null = null;\n\nexport function getDefaultStorage(): DeviceStorage {\n\tif (!defaultStorage) {\n\t\ttry {\n\t\t\tdefaultStorage = createLocalStorage();\n\t\t} catch {\n\t\t\tdefaultStorage = createNoOpStorage();\n\t\t}\n\t}\n\treturn defaultStorage;\n}\n\nexport function resetDefaultStorage(): void {\n\tdefaultStorage = null;\n}\n", "import { raceWithAbort, throwIfAborted, withTimeout } from \"../errors/errors\";\nimport {\n\tcreateEventEmitter,\n\ttype TypedEventEmitter,\n} from \"../state/event-emitter\";\nimport type {\n\tAdvertisementEvent,\n\tBLEAdapter,\n\tBLEConnectedSession,\n\tBLEConnectOptions,\n\tBLEGATTCharacteristic,\n\tBLEGATTDescriptor,\n\tBLEGATTService,\n} from \"../types\";\nimport type {\n\tBluetoothAdvertisingEvent,\n\tBluetoothDeviceWithAdvertisements,\n} from \"../types/web-bluetooth-ext\";\nimport { type DeviceStorage, getDefaultStorage } from \"../utils/storage\";\n\n/** Default timeout for GATT connection in milliseconds */\nexport const DEFAULT_CONNECTION_TIMEOUT_MS = 20000;\n\n/** Bluetooth Base UUID suffix for constructing full UUIDs */\nexport const BLUETOOTH_UUID_BASE = \"-0000-1000-8000-00805f9b34fb\";\n\n/**\n * Converts a short UUID to a full Bluetooth Base UUID.\n * @param shortId - A number (0-65535) or hex string (1-4 chars)\n * @throws RangeError if number is out of 16-bit range\n * @throws Error if string is invalid hex or empty\n */\nexport function toFullUuid(shortId: number | string): string {\n\tif (typeof shortId === \"number\") {\n\t\tif (!Number.isInteger(shortId) || shortId < 0 || shortId > 0xffff) {\n\t\t\tthrow new RangeError(\n\t\t\t\t`Short UUID must be integer 0-65535, got ${shortId}`,\n\t\t\t);\n\t\t}\n\t\treturn `0000${shortId.toString(16).padStart(4, \"0\")}${BLUETOOTH_UUID_BASE}`;\n\t}\n\n\tif (shortId.length === 0 || shortId.length > 4) {\n\t\tthrow new Error(\n\t\t\t`Invalid short UUID length: ${shortId.length} (must be 1-4)`,\n\t\t);\n\t}\n\n\tif (!/^[0-9a-fA-F]+$/.test(shortId)) {\n\t\tthrow new Error(`Invalid short UUID format: ${shortId} (must be hex)`);\n\t}\n\n\treturn `0000${shortId.toLowerCase().padStart(4, \"0\")}${BLUETOOTH_UUID_BASE}`;\n}\n\nfunction getBluetooth(): Bluetooth {\n\tif (typeof navigator === \"undefined\" || !navigator.bluetooth) {\n\t\tthrow new Error(\"Web Bluetooth not available\");\n\t}\n\treturn navigator.bluetooth;\n}\n\nfunction adaptDescriptor(\n\tdesc: BluetoothRemoteGATTDescriptor,\n): BLEGATTDescriptor {\n\treturn {\n\t\tuuid: desc.uuid,\n\t\treadValue: () => desc.readValue(),\n\t\twriteValue: (value) => desc.writeValue(value),\n\t};\n}\n\nfunction adaptCharacteristic(\n\tchar: BluetoothRemoteGATTCharacteristic,\n): BLEGATTCharacteristic {\n\treturn {\n\t\tuuid: char.uuid,\n\t\tproperties: {\n\t\t\tbroadcast: char.properties.broadcast,\n\t\t\tread: char.properties.read,\n\t\t\twriteWithoutResponse: char.properties.writeWithoutResponse,\n\t\t\twrite: char.properties.write,\n\t\t\tnotify: char.properties.notify,\n\t\t\tindicate: char.properties.indicate,\n\t\t\tauthenticatedSignedWrites: char.properties.authenticatedSignedWrites,\n\t\t\treliableWrite: char.properties.reliableWrite,\n\t\t\twritableAuxiliaries: char.properties.writableAuxiliaries,\n\t\t},\n\t\treadValue: () => char.readValue(),\n\t\twriteValueWithResponse: (value) =>\n\t\t\tchar.writeValueWithResponse(value as BufferSource),\n\t\twriteValueWithoutResponse: (value) =>\n\t\t\tchar.writeValueWithoutResponse(value as BufferSource),\n\t\tstartNotifications: () => char.startNotifications().then(() => {}),\n\t\tstopNotifications: () => char.stopNotifications().then(() => {}),\n\t\tgetDescriptor: async (uuid) => {\n\t\t\tconst desc = await char.getDescriptor(uuid);\n\t\t\treturn adaptDescriptor(desc);\n\t\t},\n\t\tgetDescriptors: async (uuid) => {\n\t\t\tconst descs = uuid\n\t\t\t\t? await char.getDescriptors(uuid)\n\t\t\t\t: await char.getDescriptors();\n\t\t\treturn descs.map(adaptDescriptor);\n\t\t},\n\t\taddEventListener: (type, listener) => char.addEventListener(type, listener),\n\t\tremoveEventListener: (type, listener) =>\n\t\t\tchar.removeEventListener(type, listener),\n\t\tget value() {\n\t\t\treturn char.value;\n\t\t},\n\t};\n}\n\nfunction adaptService(service: BluetoothRemoteGATTService): BLEGATTService {\n\treturn {\n\t\tuuid: service.uuid,\n\t\tgetCharacteristics: async () => {\n\t\t\tconst chars = await service.getCharacteristics();\n\t\t\treturn chars.map(adaptCharacteristic);\n\t\t},\n\t\tgetCharacteristic: async (uuid) => {\n\t\t\tconst char = await service.getCharacteristic(uuid);\n\t\t\treturn adaptCharacteristic(char);\n\t\t},\n\t};\n}\n\ninterface AdvertisementEvents extends Record<string, unknown> {\n\tadvertisement: AdvertisementEvent;\n}\n\n/**\n * Extracts advertising data from a raw Event with type-safe access.\n * Returns an AdvertisementEvent with only the defined properties.\n */\nfunction extractAdvertisingData(event: Event): AdvertisementEvent {\n\tconst advEvent = event as BluetoothAdvertisingEvent;\n\tconst data: AdvertisementEvent = {};\n\n\tif (advEvent.rssi !== undefined) data.rssi = advEvent.rssi;\n\tif (advEvent.name !== undefined) data.name = advEvent.name;\n\tif (advEvent.txPower !== undefined) data.txPower = advEvent.txPower;\n\tif (advEvent.manufacturerData !== undefined)\n\t\tdata.manufacturerData = advEvent.manufacturerData;\n\tif (advEvent.serviceData !== undefined)\n\t\tdata.serviceData = advEvent.serviceData;\n\tif (advEvent.uuids !== undefined) data.uuids = advEvent.uuids;\n\n\treturn data;\n}\n\nfunction createSession(server: BluetoothRemoteGATTServer): BLEConnectedSession {\n\tconst device = server.device;\n\tlet currentRssi: number | undefined;\n\tlet isWatchingAdvertisements = false;\n\tconst advertisementEmitter: TypedEventEmitter<AdvertisementEvents> =\n\t\tcreateEventEmitter();\n\n\t// Handler for advertisement events\n\tconst handleAdvertisement = (event: Event): void => {\n\t\tconst advData = extractAdvertisingData(event);\n\n\t\t// Update current RSSI\n\t\tif (advData.rssi !== undefined) {\n\t\t\tcurrentRssi = advData.rssi;\n\t\t}\n\n\t\tadvertisementEmitter.emit(\"advertisement\", advData);\n\t};\n\n\treturn {\n\t\tdeviceId: device.id,\n\t\tdeviceName: device.name,\n\t\tasync getPrimaryServices(): Promise<BLEGATTService[]> {\n\t\t\tconst services = await server.getPrimaryServices();\n\t\t\treturn services.map(adaptService);\n\t\t},\n\t\tasync getPrimaryService(\n\t\t\tuuid: BluetoothServiceUUID,\n\t\t): Promise<BLEGATTService> {\n\t\t\tconst service = await server.getPrimaryService(uuid);\n\t\t\treturn adaptService(service);\n\t\t},\n\t\tasync disconnect(): Promise<void> {\n\t\t\ttry {\n\t\t\t\t// Clean up advertisement watching\n\t\t\t\tif (isWatchingAdvertisements) {\n\t\t\t\t\tdevice.removeEventListener(\n\t\t\t\t\t\t\"advertisementreceived\",\n\t\t\t\t\t\thandleAdvertisement,\n\t\t\t\t\t);\n\t\t\t\t\tisWatchingAdvertisements = false;\n\t\t\t\t}\n\t\t\t\tserver.disconnect();\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"[web-ble-kit] Error during GATT disconnect:\",\n\t\t\t\t\te instanceof Error ? e.message : String(e),\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tonDisconnect(callback: () => void): () => void {\n\t\t\tconst handler = () => {\n\t\t\t\tcallback();\n\t\t\t};\n\t\t\tdevice.addEventListener(\"gattserverdisconnected\", handler);\n\t\t\treturn () => {\n\t\t\t\tdevice.removeEventListener(\"gattserverdisconnected\", handler);\n\t\t\t};\n\t\t},\n\n\t\t// Advertisement watching for RSSI monitoring\n\t\tasync watchAdvertisements(): Promise<void> {\n\t\t\tif (isWatchingAdvertisements) {\n\t\t\t\treturn; // Already watching\n\t\t\t}\n\n\t\t\t// Check if the API is available\n\t\t\tif (typeof device.watchAdvertisements !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"watchAdvertisements is not supported in this browser. \" +\n\t\t\t\t\t\t'Try enabling \"Experimental Web Platform features\" in chrome://flags',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdevice.addEventListener(\"advertisementreceived\", handleAdvertisement);\n\t\t\tisWatchingAdvertisements = true;\n\n\t\t\ttry {\n\t\t\t\tawait device.watchAdvertisements();\n\t\t\t} catch (e) {\n\t\t\t\t// Clean up on failure\n\t\t\t\tdevice.removeEventListener(\n\t\t\t\t\t\"advertisementreceived\",\n\t\t\t\t\thandleAdvertisement,\n\t\t\t\t);\n\t\t\t\tisWatchingAdvertisements = false;\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t},\n\n\t\tunwatchAdvertisements(): void {\n\t\t\tif (!isWatchingAdvertisements) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdevice.removeEventListener(\"advertisementreceived\", handleAdvertisement);\n\t\t\tisWatchingAdvertisements = false;\n\t\t\t// Note: Web Bluetooth API doesn't have unwatchAdvertisements()\n\t\t\t// The browser may continue scanning, but we won't receive events\n\t\t},\n\n\t\tget watchingAdvertisements(): boolean {\n\t\t\t// Use the device's property if available, fall back to our tracking\n\t\t\tconst extDevice = device as BluetoothDeviceWithAdvertisements;\n\t\t\treturn extDevice.watchingAdvertisements ?? isWatchingAdvertisements;\n\t\t},\n\n\t\tget rssi(): number | undefined {\n\t\t\treturn currentRssi;\n\t\t},\n\n\t\tonAdvertisement(callback: (event: AdvertisementEvent) => void): () => void {\n\t\t\treturn advertisementEmitter.on(\"advertisement\", callback);\n\t\t},\n\t};\n}\n\nfunction isMatchingDeviceName(\n\tname: string | undefined,\n\tprefixes: readonly string[],\n): boolean {\n\tif (!name) return false;\n\tconst trimmed = name.trim();\n\treturn prefixes.some((prefix) => trimmed.startsWith(prefix));\n}\n\nexport interface WebBluetoothAdapterOptions {\n\t/**\n\t * Storage implementation for persisting device IDs.\n\t * Defaults to localStorage with graceful fallback.\n\t */\n\tstorage?: DeviceStorage;\n\n\t/**\n\t * Timeout for GATT connection in milliseconds.\n\t * Bluetooth connections can hang for 30+ seconds on some devices.\n\t * @default 20000 (20 seconds)\n\t */\n\tconnectionTimeoutMs?: number;\n\n\t/**\n\t * Device name prefixes to match during reconnection.\n\t * Used to identify devices when no remembered device ID is available.\n\t * @default []\n\t */\n\tnamePrefixes?: readonly string[];\n\n\t/**\n\t * Optional service UUIDs to request access to.\n\t * These are added to optionalServices in requestDevice().\n\t */\n\toptionalServices?: (number | string)[];\n\n\t/**\n\t * Default filters for device discovery.\n\t * Used when no filters are provided in connect().\n\t */\n\tdefaultFilters?: BluetoothLEScanFilter[];\n\n\t/**\n\t * Log prefix for warning messages.\n\t * @default '[web-ble-kit]'\n\t */\n\tlogPrefix?: string;\n}\n\nfunction buildRequestOptions(\n\toptions: BLEConnectOptions,\n\tadapterOptions: WebBluetoothAdapterOptions,\n): RequestDeviceOptions {\n\tconst optionalServices: BluetoothServiceUUID[] = (\n\t\toptions.optionalServices ??\n\t\tadapterOptions.optionalServices ??\n\t\t[]\n\t).map((u) => (typeof u === \"number\" ? toFullUuid(u) : String(u)));\n\n\tconst filters: BluetoothLEScanFilter[] | undefined = options.filters?.length\n\t\t? options.filters\n\t\t\t\t.map((f) => {\n\t\t\t\t\tconst filter: BluetoothLEScanFilter = {};\n\t\t\t\t\tif (f.namePrefix != null)\n\t\t\t\t\t\t(filter as { namePrefix?: string }).namePrefix = f.namePrefix;\n\t\t\t\t\tif (f.name != null) (filter as { name?: string }).name = f.name;\n\t\t\t\t\tif (f.services != null)\n\t\t\t\t\t\t(filter as { services?: BluetoothServiceUUID[] }).services =\n\t\t\t\t\t\t\tf.services;\n\t\t\t\t\treturn filter;\n\t\t\t\t})\n\t\t\t\t.filter((f) => Object.keys(f).length > 0)\n\t\t: undefined;\n\n\tconst namePrefixes = adapterOptions.namePrefixes ?? [];\n\tconst defaultFilters = adapterOptions.defaultFilters ?? [];\n\n\tconst effectiveFilters: BluetoothLEScanFilter[] = filters?.length\n\t\t? filters\n\t\t: defaultFilters.length > 0\n\t\t\t? defaultFilters\n\t\t\t: namePrefixes.length > 0\n\t\t\t\t? namePrefixes.map((prefix) => ({ namePrefix: prefix }))\n\t\t\t\t: [{ acceptAllDevices: true } as unknown as BluetoothLEScanFilter];\n\n\t// Handle acceptAllDevices case\n\tconst hasAcceptAll = effectiveFilters.some(\n\t\t(f) =>\n\t\t\t\"acceptAllDevices\" in f &&\n\t\t\t(f as { acceptAllDevices?: boolean }).acceptAllDevices,\n\t);\n\n\tif (hasAcceptAll) {\n\t\treturn {\n\t\t\tacceptAllDevices: true,\n\t\t\toptionalServices,\n\t\t};\n\t}\n\n\treturn {\n\t\tfilters: effectiveFilters,\n\t\toptionalServices,\n\t};\n}\n\n/**\n * Creates a Web Bluetooth adapter that implements the BLEAdapter interface.\n * This adapter uses the native Web Bluetooth API available in modern browsers.\n *\n * @param options - Adapter configuration options\n * @returns A BLEAdapter for use with device managers\n *\n * @example Default usage (localStorage persistence)\n * ```typescript\n * const adapter = createWebBluetoothAdapter();\n * ```\n *\n * @example Disable device persistence\n * ```typescript\n * import { createNoOpStorage } from 'web-ble-kit';\n * const adapter = createWebBluetoothAdapter({ storage: createNoOpStorage() });\n * ```\n *\n * @example Custom storage\n * ```typescript\n * const adapter = createWebBluetoothAdapter({\n *   storage: {\n *     get: () => myStore.getDeviceId(),\n *     set: (id) => myStore.setDeviceId(id),\n *     remove: () => myStore.clearDeviceId(),\n *   }\n * });\n * ```\n */\nexport function createWebBluetoothAdapter(\n\toptions: WebBluetoothAdapterOptions = {},\n): BLEAdapter {\n\tconst storage = options.storage ?? getDefaultStorage();\n\tconst connectionTimeoutMs =\n\t\toptions.connectionTimeoutMs ?? DEFAULT_CONNECTION_TIMEOUT_MS;\n\tconst namePrefixes = options.namePrefixes ?? [];\n\tconst logPrefix = options.logPrefix ?? \"[web-ble-kit]\";\n\n\treturn {\n\t\tasync connect(\n\t\t\tconnectOptions: BLEConnectOptions = {},\n\t\t): Promise<BLEConnectedSession> {\n\t\t\tconst signal = connectOptions.signal;\n\n\t\t\t// Fail fast if already aborted\n\t\t\tthrowIfAborted(signal);\n\n\t\t\tconst bluetooth = getBluetooth();\n\t\t\tconst requestOptions = buildRequestOptions(connectOptions, options);\n\n\t\t\t// Race device request against abort signal\n\t\t\tconst device: BluetoothDevice = await raceWithAbort(\n\t\t\t\tbluetooth.requestDevice(requestOptions),\n\t\t\t\tsignal,\n\t\t\t);\n\n\t\t\t// Check abort after device selection (user may have cancelled during picker)\n\t\t\tthrowIfAborted(signal);\n\n\t\t\tif (!device.gatt) {\n\t\t\t\tthrow new Error(\"No GATT server\");\n\t\t\t}\n\n\t\t\tif (device.id && device.id.length > 0 && connectOptions.rememberDevice) {\n\t\t\t\tstorage.set(device.id);\n\t\t\t}\n\n\t\t\t// Race GATT connection against abort signal\n\t\t\tconst server: BluetoothRemoteGATTServer = await raceWithAbort(\n\t\t\t\twithTimeout(\n\t\t\t\t\tdevice.gatt.connect(),\n\t\t\t\t\tconnectionTimeoutMs,\n\t\t\t\t\t\"GATT connection\",\n\t\t\t\t),\n\t\t\t\tsignal,\n\t\t\t);\n\n\t\t\treturn createSession(server);\n\t\t},\n\n\t\tasync reconnect(): Promise<BLEConnectedSession | null> {\n\t\t\tconst bluetooth = getBluetooth();\n\n\t\t\tif (typeof bluetooth.getDevices !== \"function\") {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst devices: BluetoothDevice[] = await bluetooth.getDevices();\n\t\t\tconst rememberedId = storage.get();\n\n\t\t\tconst preferredDevice = rememberedId\n\t\t\t\t? devices.find((d) => d.id === rememberedId)\n\t\t\t\t: undefined;\n\t\t\tconst targetDevice =\n\t\t\t\tpreferredDevice ??\n\t\t\t\tdevices.find((d) => isMatchingDeviceName(d.name, namePrefixes));\n\n\t\t\tif (!targetDevice?.gatt) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst server: BluetoothRemoteGATTServer = await withTimeout(\n\t\t\t\t\ttargetDevice.gatt.connect(),\n\t\t\t\t\tconnectionTimeoutMs,\n\t\t\t\t\t\"GATT reconnection\",\n\t\t\t\t);\n\t\t\t\treturn createSession(server);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`${logPrefix} Reconnect failed:`,\n\t\t\t\t\te instanceof Error ? e.message : String(e),\n\t\t\t\t);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\t\tforgetDevice(): void {\n\t\t\tstorage.remove();\n\t\t},\n\n\t\tasync getAvailability(): Promise<boolean> {\n\t\t\ttry {\n\t\t\t\tconst bluetooth = getBluetooth();\n\t\t\t\tif (typeof bluetooth.getAvailability === \"function\") {\n\t\t\t\t\treturn bluetooth.getAvailability();\n\t\t\t\t}\n\t\t\t\t// If getAvailability is not supported, assume available\n\t\t\t\t// since we were able to get the bluetooth object\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\t// Web Bluetooth not available\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t};\n}\n", "const supportsWeakRef = typeof WeakRef !== \"undefined\";\n\n/**\n * Type guard to check if a value can be used with WeakRef.\n * WeakRef only accepts objects (not primitives or null).\n */\nfunction isWeakRefCompatible(value: unknown): value is object {\n\treturn (\n\t\tvalue !== null && (typeof value === \"object\" || typeof value === \"function\")\n\t);\n}\n\nexport interface PollManagerOptions {\n\t/** Default polling interval in milliseconds */\n\tdefaultIntervalMs: number;\n\t/** Callback when a poll error occurs */\n\tonError: (error: Error) => void;\n\t/** Maximum consecutive errors before stopping polling */\n\tmaxConsecutiveErrors?: number;\n}\n\nexport interface PollStartOptions {\n\t/** Override the default polling interval */\n\tintervalMs?: number;\n}\n\nexport interface PollManager<TContext> {\n\tstart(context: TContext, options?: PollStartOptions): void;\n\tstop(): void;\n\tisPolling(): boolean;\n}\n\n/**\n * Creates a generic poll manager.\n *\n * @param pollFn - The function to call on each poll. Receives the context.\n * @param options - Configuration options\n * @returns A poll manager instance\n */\nexport function createPollManager<TContext>(\n\tpollFn: (context: TContext) => Promise<void>,\n\toptions: PollManagerOptions,\n): PollManager<TContext> {\n\tconst { defaultIntervalMs, onError, maxConsecutiveErrors = 3 } = options;\n\n\tlet pollTimer: ReturnType<typeof setInterval> | null = null;\n\tlet sessionId = 0;\n\n\tfunction stop(): void {\n\t\tif (pollTimer !== null) {\n\t\t\tclearInterval(pollTimer);\n\t\t\tpollTimer = null;\n\t\t}\n\t\tsessionId = sessionId >= Number.MAX_SAFE_INTEGER ? 1 : sessionId + 1;\n\t}\n\n\tfunction start(context: TContext, startOptions: PollStartOptions = {}): void {\n\t\tstop();\n\n\t\tconst intervalMs = startOptions.intervalMs ?? defaultIntervalMs;\n\n\t\tconst currentSessionId = sessionId;\n\n\t\t// Use WeakRef only if supported AND context is an object (not primitive/null).\n\t\tconst contextRef =\n\t\t\tsupportsWeakRef && isWeakRefCompatible(context)\n\t\t\t\t? new WeakRef(context)\n\t\t\t\t: { deref: () => context };\n\n\t\tlet consecutiveErrors = 0;\n\n\t\tpollTimer = setInterval(() => {\n\t\t\tif (currentSessionId !== sessionId) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst currentContext = contextRef.deref() as TContext | undefined;\n\n\t\t\t// Check specifically for undefined (GC'd WeakRef), not falsy values\n\t\t\t// This allows null, 0, '', false as valid contexts\n\t\t\tif (currentContext === undefined) {\n\t\t\t\tstop();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpollFn(currentContext)\n\t\t\t\t.then(() => {\n\t\t\t\t\tconsecutiveErrors = 0;\n\t\t\t\t})\n\t\t\t\t.catch((e: unknown) => {\n\t\t\t\t\tconsecutiveErrors++;\n\t\t\t\t\tonError(e instanceof Error ? e : new Error(String(e)));\n\n\t\t\t\t\tif (consecutiveErrors >= maxConsecutiveErrors) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\"[web-ble-kit:poll-manager] Too many consecutive errors, stopping polling\",\n\t\t\t\t\t\t);\n\t\t\t\t\t\tstop();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}, intervalMs);\n\t}\n\n\tfunction isPolling(): boolean {\n\t\treturn pollTimer !== null;\n\t}\n\n\treturn {\n\t\tstart,\n\t\tstop,\n\t\tisPolling,\n\t};\n}\n", "import retry from 'retry';\nimport isNetworkError from 'is-network-error';\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nexport default async function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {...options};\n\t\toptions.onFailedAttempt ??= () => {};\n\t\toptions.shouldRetry ??= () => true;\n\t\toptions.retries ??= 10;\n\n\t\tconst operation = retry.operation(options);\n\n\t\tconst abortHandler = () => {\n\t\t\toperation.stop();\n\t\t\treject(options.signal?.reason);\n\t\t};\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tconst cleanUp = () => {\n\t\t\toptions.signal?.removeEventListener('abort', abortHandler);\n\t\t\toperation.stop();\n\t\t};\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tconst result = await input(attemptNumber);\n\t\t\t\tcleanUp();\n\t\t\t\tresolve(result);\n\t\t\t} catch (error) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\t\tthrow new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\t\tthrow error.originalError;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof TypeError && !isNetworkError(error)) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\tif (!(await options.shouldRetry(error))) {\n\t\t\t\t\t\toperation.stop();\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\tthrow operation.mainError();\n\t\t\t\t\t}\n\t\t\t\t} catch (finalError) {\n\t\t\t\t\tdecorateErrorWithCounts(finalError, attemptNumber, options);\n\t\t\t\t\tcleanUp();\n\t\t\t\t\treject(finalError);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n", "const objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n\t' A network error occurred.', // Bun (WebKit)\n\t'Network connection lost', // Cloudflare Workers (fetch)\n]);\n\nexport default function isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\tconst {message, stack} = error;\n\n\t// Safari 17+ has generic message but no stack for network errors\n\tif (message === 'Load failed') {\n\t\treturn stack === undefined\n\t\t\t// Sentry adds its own stack trace to the fetch error, so also check for that\n\t\t\t|| '__sentry_captured__' in error;\n\t}\n\n\t// Deno network errors start with specific text\n\tif (message.startsWith('error sending request for url')) {\n\t\treturn true;\n\t}\n\n\t// Standard network error messages\n\treturn errorMessages.has(message);\n}\n", "import { raceWithAbort, throwIfAborted, withTimeout } from \"../errors/errors\";\nimport type { BLEGATTCharacteristic } from \"../types\";\n\n/**\n * Options for BLE write operations.\n */\nexport interface WriteOptions {\n\t/** Timeout for the write operation in milliseconds */\n\ttimeoutMs?: number;\n\t/** AbortSignal to cancel the write operation */\n\tsignal?: AbortSignal;\n}\n\n/**\n * Options for BLE read operations.\n */\nexport interface ReadOptions {\n\t/** Timeout for the read operation in milliseconds */\n\ttimeoutMs?: number;\n\t/** AbortSignal to cancel the read operation */\n\tsignal?: AbortSignal;\n}\n\n/** Default timeout for BLE write operations in milliseconds */\nexport const DEFAULT_WRITE_TIMEOUT_MS = 10000;\n\n/** Default timeout for starting BLE notifications in milliseconds */\nexport const DEFAULT_NOTIFICATION_TIMEOUT_MS = 15000;\n\n/**\n * Checks if a UUID matches a short UUID identifier.\n * Handles short IDs of 1-4 hex characters and full 128-bit Bluetooth Base UUIDs.\n * Full UUID format: 0000XXXX-0000-1000-8000-00805f9b34fb where XXXX is the short ID (zero-padded).\n *\n * @example\n * uuidMatches('0000fe00-0000-1000-8000-00805f9b34fb', 'fe00') // true\n * uuidMatches('00000001-0000-1000-8000-00805f9b34fb', '1')    // true\n * uuidMatches('00000001-0000-1000-8000-00805f9b34fb', '01')   // true\n */\nexport function uuidMatches(uuid: string, shortId: string): boolean {\n\tconst normalized = uuid.toLowerCase();\n\t// Pad short ID to 4 characters for consistent comparison\n\tconst shortNormalized = shortId.toLowerCase().padStart(4, \"0\");\n\n\t// Direct match for short UUIDs (also pad the uuid if it's short)\n\tconst normalizedPadded =\n\t\tnormalized.length <= 4 ? normalized.padStart(4, \"0\") : normalized;\n\tif (normalizedPadded === shortNormalized) {\n\t\treturn true;\n\t}\n\n\t// For full UUIDs, the short ID appears at position 4-8 (after '0000')\n\t// Format: 0000XXXX-0000-1000-8000-00805f9b34fb\n\tif (normalized.length === 36 && normalized.charAt(8) === \"-\") {\n\t\tconst extractedShortId = normalized.substring(4, 8);\n\t\treturn extractedShortId === shortNormalized;\n\t}\n\n\treturn false;\n}\n\n/**\n * Safely extracts an ArrayBuffer from a DataView.\n * Returns a copy to handle potential detached buffer issues.\n * If the buffer is detached or inaccessible, returns null.\n */\nexport function extractArrayBuffer(\n\tvalue: DataView | undefined,\n): ArrayBuffer | null {\n\tif (!value) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\t// Access byteLength first - this will throw if buffer is detached\n\t\tconst byteLength = value.byteLength;\n\n\t\t// Empty views are valid but useless for our purposes\n\t\tif (byteLength === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Verify buffer is accessible by checking its byteLength\n\t\t// A detached buffer will throw when accessing properties\n\t\tconst bufferLength = value.buffer.byteLength;\n\n\t\t// Sanity check: view's byte range must fit within buffer\n\t\tif (value.byteOffset + byteLength > bufferLength) {\n\t\t\t// Invalid state - buffer may have been transferred\n\t\t\treturn null;\n\t\t}\n\n\t\t// Create a copy of the relevant portion of the buffer\n\t\t// This handles DataViews with offset and avoids detached buffer issues\n\t\tconst copy = new Uint8Array(byteLength);\n\t\tconst source = new Uint8Array(value.buffer, value.byteOffset, byteLength);\n\t\tcopy.set(source);\n\t\treturn copy.buffer;\n\t} catch {\n\t\t// Buffer is detached or otherwise inaccessible\n\t\t// This catch handles TypeError thrown when accessing detached buffer properties\n\t\treturn null;\n\t}\n}\n\n/**\n * Gets the byte length of a buffer-like object.\n * All buffer-like types (ArrayBuffer, Uint8Array, DataView) share the byteLength property.\n */\nfunction getByteLength(data: ArrayBuffer | Uint8Array | DataView): number {\n\treturn data.byteLength;\n}\n\n/**\n * Writes data to a characteristic with a timeout and optional abort support.\n * BLE writes can hang indefinitely, so all user-facing write operations\n * should use this to prevent the app from becoming unresponsive.\n *\n * @warning **Non-cancellable Operation**: The abort signal or timeout will reject\n * the promise early, but the underlying BLE write continues in the background.\n * The device may still receive and process the data. This is a fundamental\n * limitation of the Web Bluetooth API - operations cannot be truly cancelled.\n * Verify device state after timeouts before retrying.\n *\n * @param char - The characteristic to write to\n * @param data - The data to write\n * @param options - Timeout and signal options (or just timeout in ms for backwards compatibility)\n * @throws Error if data is empty\n * @throws AbortError if the signal is aborted\n * @throws TimeoutError if the operation times out\n */\nexport async function writeWithTimeout(\n\tchar: BLEGATTCharacteristic,\n\tdata: ArrayBuffer | Uint8Array | DataView,\n\toptions: WriteOptions | number = DEFAULT_WRITE_TIMEOUT_MS,\n): Promise<void> {\n\tconst opts: WriteOptions =\n\t\ttypeof options === \"number\" ? { timeoutMs: options } : options;\n\tconst timeoutMs = opts.timeoutMs ?? DEFAULT_WRITE_TIMEOUT_MS;\n\tconst signal = opts.signal;\n\n\tthrowIfAborted(signal);\n\n\tif (getByteLength(data) === 0) {\n\t\tthrow new Error(\n\t\t\t\"Empty data: cannot write zero bytes to BLE characteristic\",\n\t\t);\n\t}\n\n\tconst writePromise = withTimeout(\n\t\tchar.writeValueWithResponse(data),\n\t\ttimeoutMs,\n\t\t\"BLE write\",\n\t);\n\tawait raceWithAbort(writePromise, signal);\n}\n\n/** Default timeout for BLE read operations in milliseconds */\nexport const DEFAULT_READ_TIMEOUT_MS = 5000;\n\n/**\n * Reads the current value from a characteristic with a timeout and optional abort support.\n * BLE reads can hang indefinitely, so all user-facing read operations\n * should use this to prevent the app from becoming unresponsive.\n *\n * @warning **Non-cancellable Operation**: The abort signal or timeout will reject\n * the promise early, but the underlying BLE read continues in the background.\n * This is a fundamental limitation of the Web Bluetooth API.\n *\n * @param char - The characteristic to read from\n * @param options - Timeout and signal options (or just timeout in ms for backwards compatibility)\n * @returns Promise resolving to the characteristic value\n * @throws AbortError if the signal is aborted\n * @throws TimeoutError if the read takes too long\n */\nexport async function readWithTimeout(\n\tchar: BLEGATTCharacteristic,\n\toptions: ReadOptions | number = DEFAULT_READ_TIMEOUT_MS,\n): Promise<DataView> {\n\tconst opts: ReadOptions =\n\t\ttypeof options === \"number\" ? { timeoutMs: options } : options;\n\tconst timeoutMs = opts.timeoutMs ?? DEFAULT_READ_TIMEOUT_MS;\n\tconst signal = opts.signal;\n\n\tthrowIfAborted(signal);\n\n\tconst readPromise = withTimeout(char.readValue(), timeoutMs, \"BLE read\");\n\treturn raceWithAbort(readPromise, signal);\n}\n\n/**\n * Options for starting notifications.\n */\nexport interface StartNotificationsOptions {\n\t/** Timeout for starting notifications in milliseconds */\n\ttimeoutMs?: number;\n\t/** Log prefix for warning messages */\n\tlogPrefix?: string;\n\t/** AbortSignal to cancel the notification setup */\n\tsignal?: AbortSignal;\n}\n\n/**\n * Starts notifications on a characteristic with timeout protection.\n * Returns a cleanup function to stop notifications and remove listeners.\n *\n * @warning **Non-cancellable Setup**: The abort signal or timeout will reject\n * the promise early, but the underlying notification setup may still complete.\n * This is a fundamental limitation of the Web Bluetooth API.\n *\n * @param char - The characteristic to start notifications on\n * @param onData - Callback invoked when data is received\n * @param options - Options including timeout, logger, and signal\n * @throws TimeoutError if notification setup takes too long\n * @throws AbortError if the signal is aborted\n */\nexport async function startNotifications(\n\tchar: BLEGATTCharacteristic,\n\tonData: (data: ArrayBuffer) => void,\n\toptions: StartNotificationsOptions | number = {},\n): Promise<() => void> {\n\t// Support legacy signature: startNotifications(char, onData, timeoutMs)\n\tconst opts = typeof options === \"number\" ? { timeoutMs: options } : options;\n\tconst timeoutMs = opts.timeoutMs ?? DEFAULT_NOTIFICATION_TIMEOUT_MS;\n\tconst logPrefix = opts.logPrefix ?? \"[web-ble-kit]\";\n\tconst signal = opts.signal;\n\n\tthrowIfAborted(signal);\n\n\tconst listener = (ev: Event): void => {\n\t\tconst ch = ev.target as unknown as BLEGATTCharacteristic;\n\t\tconst ab = extractArrayBuffer(ch.value);\n\t\tif (ab) {\n\t\t\tonData(ab);\n\t\t}\n\t};\n\n\tconst setupPromise = withTimeout(\n\t\tchar.startNotifications(),\n\t\ttimeoutMs,\n\t\t\"BLE notification setup\",\n\t);\n\tawait raceWithAbort(setupPromise, signal);\n\n\tchar.addEventListener(\"characteristicvaluechanged\", listener);\n\n\t// Fix F-020: Make cleanup idempotent to prevent double-stop issues\n\tlet cleaned = false;\n\treturn () => {\n\t\tif (cleaned) return;\n\t\tcleaned = true;\n\n\t\tchar.removeEventListener(\"characteristicvaluechanged\", listener);\n\t\tchar.stopNotifications().catch((e: unknown) => {\n\t\t\tconsole.warn(\n\t\t\t\t`${logPrefix} Error stopping notifications:`,\n\t\t\t\te instanceof Error ? e.message : String(e),\n\t\t\t);\n\t\t});\n\t};\n}\n", "import pRetry, { AbortError as PRetryAbortError } from \"p-retry\";\nimport {\n\tDEFAULT_READ_TIMEOUT_MS,\n\tDEFAULT_WRITE_TIMEOUT_MS,\n\treadWithTimeout,\n\twriteWithTimeout,\n} from \"../ble/transport\";\nimport { AbortError, TimeoutError } from \"../errors\";\nimport type {\n\tBLEAdapter,\n\tBLEConnectedSession,\n\tBLEConnectOptions,\n\tBLEGATTCharacteristic,\n} from \"../types\";\n\n/**\n * Options for configuring retry behavior with exponential backoff.\n */\nexport interface RetryOptions {\n\t/** Maximum number of retry attempts (default: 3) */\n\tmaxAttempts?: number;\n\t/** Initial delay in ms (default: 1000) */\n\tinitialDelayMs?: number;\n\t/** Maximum delay in ms (default: 30000) */\n\tmaxDelayMs?: number;\n\t/** Multiplier for exponential backoff (default: 2) */\n\tbackoffMultiplier?: number;\n\t/** Add random jitter to prevent thundering herd (default: true) */\n\tjitter?: boolean;\n\t/** AbortSignal to cancel retries */\n\tsignal?: AbortSignal;\n\t/** Called before each retry with attempt number and delay */\n\tonRetry?: (attempt: number, delayMs: number, error: Error) => void;\n\t/** Predicate to determine if error is retryable (default: isTransientBLEError) */\n\tisRetryable?: (error: Error) => boolean;\n}\n\n/**\n * Determines if a BLE error is transient and worth retrying.\n *\n * Retries on:\n * - Timeout errors\n * - Network errors\n * - GATT operation failed\n * - Connection/disconnect errors\n *\n * Does NOT retry on:\n * - User cancelled (AbortError)\n * - Device not found\n * - Security errors\n * - NotAllowedError (user denied permission)\n * - Unknown errors (fail-fast behavior for safety)\n *\n * @remarks\n * Unknown errors default to non-retryable (fail-fast) to prevent masking\n * unexpected issues. If you need to retry unknown errors, provide a custom\n * `isRetryable` predicate to `withRetry()`.\n */\nexport function isTransientBLEError(error: Error): boolean {\n\t// Never retry abort errors - user explicitly cancelled\n\tif (error instanceof AbortError || error.name === \"AbortError\") {\n\t\treturn false;\n\t}\n\n\t// Timeout errors are retryable\n\tif (error instanceof TimeoutError || error.name === \"TimeoutError\") {\n\t\treturn true;\n\t}\n\n\tconst message = error.message.toLowerCase();\n\tconst name = error.name.toLowerCase();\n\n\t// Don't retry user cancellation or permission errors\n\tconst nonRetryablePatterns = [\n\t\t\"user cancelled\",\n\t\t\"user canceled\",\n\t\t\"user denied\",\n\t\t\"notallowederror\",\n\t\t\"securityerror\",\n\t\t\"not found\",\n\t\t\"no device selected\",\n\t\t\"permission denied\",\n\t];\n\n\tfor (const pattern of nonRetryablePatterns) {\n\t\tif (message.includes(pattern) || name.includes(pattern)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Retry network and GATT errors\n\tconst retryablePatterns = [\n\t\t\"network\",\n\t\t\"gatt\",\n\t\t\"connection\",\n\t\t\"disconnect\",\n\t\t\"failed to execute\",\n\t\t\"operation failed\",\n\t\t\"not connected\",\n\t];\n\n\tfor (const pattern of retryablePatterns) {\n\t\tif (message.includes(pattern) || name.includes(pattern)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Default: do NOT retry unknown errors (fail-fast for safety)\n\treturn false;\n}\n\n/**\n * Executes an operation with automatic retry and exponential backoff.\n * Uses p-retry under the hood.\n *\n * @example Basic usage\n * ```typescript\n * const result = await withRetry(() => riskyOperation(), {\n *   maxAttempts: 5,\n *   initialDelayMs: 500,\n * });\n * ```\n *\n * @example With abort support\n * ```typescript\n * const controller = new AbortController();\n * setTimeout(() => controller.abort(), 10000);\n *\n * const result = await withRetry(() => bleOperation(), {\n *   signal: controller.signal,\n *   onRetry: (attempt, delay, error) => {\n *     console.log(`Retry ${attempt} after ${delay}ms: ${error.message}`);\n *   },\n * });\n * ```\n *\n * @param operation - The async operation to execute\n * @param options - Retry configuration options\n * @returns Promise resolving to the operation result\n * @throws The last error if all retries fail, or AbortError if cancelled\n */\nexport async function withRetry<T>(\n\toperation: () => Promise<T>,\n\toptions: RetryOptions = {},\n): Promise<T> {\n\tconst {\n\t\tmaxAttempts = 3,\n\t\tinitialDelayMs = 1000,\n\t\tmaxDelayMs = 30000,\n\t\tbackoffMultiplier = 2,\n\t\tjitter = true,\n\t\tsignal,\n\t\tonRetry,\n\t\tisRetryable = isTransientBLEError,\n\t} = options;\n\n\tif (maxAttempts < 1) {\n\t\tthrow new RangeError(`maxAttempts must be >= 1, got ${maxAttempts}`);\n\t}\n\n\t// Fail fast if already aborted\n\tif (signal?.aborted) {\n\t\tthrow new AbortError(signal.reason?.message ?? \"Operation aborted\");\n\t}\n\n\t// Ensure initialDelayMs doesn't exceed maxDelayMs (p-retry requires minTimeout <= maxTimeout)\n\tconst effectiveInitialDelay = Math.min(initialDelayMs, maxDelayMs);\n\n\ttry {\n\t\treturn await pRetry(\n\t\t\tasync () => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await operation();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconst error = e instanceof Error ? e : new Error(String(e));\n\n\t\t\t\t\t// If not retryable, throw p-retry's AbortError to stop retrying\n\t\t\t\t\tif (!isRetryable(error)) {\n\t\t\t\t\t\tthrow new PRetryAbortError(error.message);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t// p-retry uses retries (extra attempts after first), we use maxAttempts (total)\n\t\t\t\tretries: maxAttempts - 1,\n\t\t\t\tminTimeout: effectiveInitialDelay,\n\t\t\t\tmaxTimeout: maxDelayMs,\n\t\t\t\tfactor: backoffMultiplier,\n\t\t\t\trandomize: jitter,\n\t\t\t\t...(signal && { signal }),\n\t\t\t\tonFailedAttempt: (error) => {\n\t\t\t\t\t// Only call onRetry if there are retries left\n\t\t\t\t\tif (error.retriesLeft > 0 && onRetry) {\n\t\t\t\t\t\t// Calculate what the delay will be (approximate, p-retry handles actual timing)\n\t\t\t\t\t\tconst attempt = error.attemptNumber;\n\t\t\t\t\t\tconst delayMs = Math.min(\n\t\t\t\t\t\t\teffectiveInitialDelay * backoffMultiplier ** (attempt - 1),\n\t\t\t\t\t\t\tmaxDelayMs,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tonRetry(attempt, delayMs, error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t} catch (e) {\n\t\t// Convert p-retry's AbortError back to our AbortError for signal aborts\n\t\tif (e instanceof Error && e.name === \"AbortError\" && signal?.aborted) {\n\t\t\tthrow new AbortError(signal.reason?.message ?? \"Operation aborted\");\n\t\t}\n\t\tthrow e;\n\t}\n}\n\n/**\n * Options for BLE operations with retry support.\n */\nexport interface BLERetryOptions extends RetryOptions {\n\t/** Timeout for the BLE operation in ms */\n\ttimeoutMs?: number;\n}\n\n/**\n * Reads from a BLE characteristic with automatic retry on transient failures.\n *\n * @example\n * ```typescript\n * const value = await readWithRetry(characteristic, {\n *   maxAttempts: 3,\n *   timeoutMs: 5000,\n * });\n * ```\n *\n * @param char - The characteristic to read from\n * @param options - Retry and timeout options\n * @returns Promise resolving to the characteristic value\n */\nexport async function readWithRetry(\n\tchar: BLEGATTCharacteristic,\n\toptions: BLERetryOptions = {},\n): Promise<DataView> {\n\tconst { timeoutMs = DEFAULT_READ_TIMEOUT_MS, ...retryOptions } = options;\n\n\treturn withRetry(() => readWithTimeout(char, timeoutMs), retryOptions);\n}\n\n/**\n * Writes to a BLE characteristic with automatic retry on transient failures.\n *\n * @example\n * ```typescript\n * await writeWithRetry(characteristic, new Uint8Array([0x01, 0x02]), {\n *   maxAttempts: 3,\n *   timeoutMs: 10000,\n * });\n * ```\n *\n * @param char - The characteristic to write to\n * @param data - The data to write\n * @param options - Retry and timeout options\n */\nexport async function writeWithRetry(\n\tchar: BLEGATTCharacteristic,\n\tdata: BufferSource,\n\toptions: BLERetryOptions = {},\n): Promise<void> {\n\tconst { timeoutMs = DEFAULT_WRITE_TIMEOUT_MS, ...retryOptions } = options;\n\n\treturn withRetry(\n\t\t() =>\n\t\t\twriteWithTimeout(\n\t\t\t\tchar,\n\t\t\t\tdata as ArrayBuffer | Uint8Array | DataView,\n\t\t\t\ttimeoutMs,\n\t\t\t),\n\t\tretryOptions,\n\t);\n}\n\n/**\n * Connects to a BLE device with automatic retry on transient failures.\n *\n * @example\n * ```typescript\n * const session = await connectWithRetry(adapter, {\n *   filters: [{ namePrefix: 'MyDevice' }],\n * }, {\n *   maxAttempts: 3,\n *   onRetry: (attempt, delay, error) => {\n *     console.log(`Connection attempt ${attempt} failed, retrying in ${delay}ms`);\n *   },\n * });\n * ```\n *\n * @param adapter - The BLE adapter to use\n * @param connectOptions - Options for the connection\n * @param retryOptions - Retry configuration\n * @returns Promise resolving to the connected session\n */\nexport async function connectWithRetry(\n\tadapter: BLEAdapter,\n\tconnectOptions: BLEConnectOptions = {},\n\tretryOptions: RetryOptions = {},\n): Promise<BLEConnectedSession> {\n\t// Pass the abort signal to both retry logic and connect options\n\tconst signal = retryOptions.signal ?? connectOptions.signal;\n\n\t// Build connect options, only include signal if defined\n\tconst finalConnectOptions: BLEConnectOptions = { ...connectOptions };\n\tif (signal) {\n\t\tfinalConnectOptions.signal = signal;\n\t}\n\n\t// Build retry options, only include signal if defined\n\tconst finalRetryOptions: RetryOptions = { ...retryOptions };\n\tif (signal) {\n\t\tfinalRetryOptions.signal = signal;\n\t}\n\n\treturn withRetry(\n\t\t() => adapter.connect(finalConnectOptions),\n\t\tfinalRetryOptions,\n\t);\n}\n", "import { createWebBluetoothAdapter } from \"../adapter/web-bluetooth\";\nimport type { RetryOptions } from \"../async/retry\";\nimport { connectWithRetry } from \"../async/retry\";\nimport {\n\tcreateEventEmitter,\n\ttype TypedEventEmitter,\n} from \"../state/event-emitter\";\nimport type {\n\tBLEAdapter,\n\tBLEConnectedSession,\n\tBLEConnectOptions,\n} from \"../types\";\n\n/**\n * Maximum concurrent BLE connections per Bluetooth adapter.\n * This is a hardware/spec limitation, not software.\n */\nexport const MAX_BLE_CONNECTIONS = 7;\n\n/**\n * Events emitted by the connection pool.\n */\nexport interface ConnectionPoolEvents extends Record<string, unknown> {\n\t/** Fired when a device connects */\n\tconnect: { deviceId: string; session: BLEConnectedSession };\n\t/** Fired when a device disconnects */\n\tdisconnect: { deviceId: string };\n}\n\n/**\n * Options for creating a connection pool.\n */\nexport interface ConnectionPoolOptions {\n\t/**\n\t * Maximum concurrent connections.\n\t * @default 7 (BLE spec limit)\n\t */\n\tmaxConnections?: number;\n\n\t/**\n\t * Factory function to create adapters for each device.\n\t * Defaults to createWebBluetoothAdapter().\n\t */\n\tcreateAdapter?: () => BLEAdapter;\n\n\t/**\n\t * Enable automatic reconnection on unexpected disconnect.\n\t * @default false\n\t */\n\tautoReconnect?: boolean;\n\n\t/**\n\t * Retry options for auto-reconnect attempts.\n\t */\n\treconnectOptions?: RetryOptions;\n}\n\n/**\n * Manages multiple concurrent BLE connections.\n *\n * The pool tracks connected devices and provides a unified interface\n * for managing multiple simultaneous BLE connections.\n */\nexport interface ConnectionPool {\n\t/**\n\t * Connect to a new device.\n\t * Shows the browser's device picker dialog.\n\t *\n\t * @param options - Connection options including filters\n\t * @returns Promise resolving to the connected session\n\t * @throws Error if max connections reached or connection fails\n\t */\n\tconnect(options?: BLEConnectOptions): Promise<BLEConnectedSession>;\n\n\t/**\n\t * Get an existing session by device ID.\n\t *\n\t * @param deviceId - The device ID to look up\n\t * @returns The session if connected, null otherwise\n\t */\n\tgetSession(deviceId: string): BLEConnectedSession | null;\n\n\t/**\n\t * Check if a device is currently connected.\n\t *\n\t * @param deviceId - The device ID to check\n\t * @returns True if the device is connected\n\t */\n\tisConnected(deviceId: string): boolean;\n\n\t/**\n\t * Disconnect a specific device.\n\t *\n\t * @param deviceId - The device ID to disconnect\n\t */\n\tdisconnect(deviceId: string): Promise<void>;\n\n\t/**\n\t * Disconnect all connected devices.\n\t */\n\tdisconnectAll(): Promise<void>;\n\n\t/**\n\t * Get all active sessions.\n\t *\n\t * @returns Map of device IDs to sessions\n\t */\n\tgetSessions(): Map<string, BLEConnectedSession>;\n\n\t/**\n\t * Get the number of active connections.\n\t */\n\treadonly connectionCount: number;\n\n\t/**\n\t * Get the maximum allowed connections.\n\t */\n\treadonly maxConnections: number;\n\n\t/**\n\t * Register a callback for device connection events.\n\t *\n\t * @param callback - Called when a device connects\n\t * @returns Unsubscribe function\n\t */\n\tonConnect(\n\t\tcallback: (deviceId: string, session: BLEConnectedSession) => void,\n\t): () => void;\n\n\t/**\n\t * Register a callback for device disconnection events.\n\t *\n\t * @param callback - Called when a device disconnects\n\t * @returns Unsubscribe function\n\t */\n\tonDisconnect(callback: (deviceId: string) => void): () => void;\n}\n\n/**\n * Creates a connection pool for managing multiple BLE device connections.\n *\n * @example Basic usage\n * ```typescript\n * const pool = createConnectionPool();\n *\n * // Connect to multiple devices\n * const session1 = await pool.connect({ filters: [{ namePrefix: 'Device1' }] });\n * const session2 = await pool.connect({ filters: [{ namePrefix: 'Device2' }] });\n *\n * // Check connection status\n * console.log('Connected devices:', pool.connectionCount);\n *\n * // Disconnect all\n * await pool.disconnectAll();\n * ```\n *\n * @example With auto-reconnect\n * ```typescript\n * const pool = createConnectionPool({\n *   autoReconnect: true,\n *   reconnectOptions: {\n *     maxAttempts: 5,\n *     onRetry: (attempt, delay) => {\n *       console.log(`Reconnect attempt ${attempt} in ${delay}ms`);\n *     },\n *   },\n * });\n *\n * pool.onDisconnect((deviceId) => {\n *   console.log(`Device ${deviceId} disconnected`);\n * });\n * ```\n *\n * @param options - Pool configuration options\n * @returns A connection pool instance\n */\nexport function createConnectionPool(\n\toptions: ConnectionPoolOptions = {},\n): ConnectionPool {\n\tconst {\n\t\tmaxConnections = MAX_BLE_CONNECTIONS,\n\t\tcreateAdapter = () => createWebBluetoothAdapter(),\n\t\tautoReconnect = false,\n\t\treconnectOptions = {},\n\t} = options;\n\n\tconst sessions = new Map<string, BLEConnectedSession>();\n\tconst adapters = new Map<string, BLEAdapter>();\n\tconst disconnectCleanups = new Map<string, () => void>();\n\tconst emitter: TypedEventEmitter<ConnectionPoolEvents> = createEventEmitter();\n\t// Fix F-018: Track devices currently attempting reconnection\n\tconst reconnectingDevices = new Set<string>();\n\t// Fix M-001: Track pending connections to prevent race conditions\n\tlet pendingConnections = 0;\n\n\t// Internal function to handle disconnect\n\tfunction handleDisconnect(deviceId: string): void {\n\t\tconst session = sessions.get(deviceId);\n\t\tif (!session) return;\n\n\t\t// Clean up\n\t\tsessions.delete(deviceId);\n\t\tconst cleanup = disconnectCleanups.get(deviceId);\n\t\tif (cleanup) {\n\t\t\tcleanup();\n\t\t\tdisconnectCleanups.delete(deviceId);\n\t\t}\n\n\t\temitter.emit(\"disconnect\", { deviceId });\n\n\t\t// Attempt auto-reconnect if enabled\n\t\tif (autoReconnect) {\n\t\t\tconst adapter = adapters.get(deviceId);\n\t\t\tif (adapter?.reconnect) {\n\t\t\t\treconnectDevice(deviceId, adapter).catch(() => {\n\t\t\t\t\t// Reconnect failed, adapter is cleaned up\n\t\t\t\t\tadapters.delete(deviceId);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// Clean up adapter if not auto-reconnecting\n\t\t\tadapters.delete(deviceId);\n\t\t}\n\t}\n\n\t// Internal function to attempt reconnection\n\t// Fix F-018: Track reconnecting state to prevent race conditions\n\tasync function reconnectDevice(\n\t\tdeviceId: string,\n\t\tadapter: BLEAdapter,\n\t): Promise<void> {\n\t\tif (!adapter.reconnect) return;\n\n\t\t// Mark as reconnecting\n\t\treconnectingDevices.add(deviceId);\n\n\t\ttry {\n\t\t\t// H-003 fix: Use async function to preserve error context\n\t\t\tconst session = await connectWithRetry(\n\t\t\t\t{\n\t\t\t\t\tconnect: async () => {\n\t\t\t\t\t\tconst result = await adapter.reconnect?.();\n\t\t\t\t\t\tif (!result)\n\t\t\t\t\t\t\tthrow new Error(\"No device available for reconnection\");\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t},\n\t\t\t\t} as BLEAdapter,\n\t\t\t\t{},\n\t\t\t\treconnectOptions,\n\t\t\t);\n\n\t\t\t// Fix F-018: Check if user called disconnect() while we were reconnecting\n\t\t\tif (!reconnectingDevices.has(deviceId)) {\n\t\t\t\t// User explicitly disconnected during reconnect, clean up the new session\n\t\t\t\tawait session.disconnect().catch(() => {});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Re-register the session\n\t\t\tsessions.set(deviceId, session);\n\n\t\t\t// Set up disconnect handler\n\t\t\tif (session.onDisconnect) {\n\t\t\t\tconst cleanup = session.onDisconnect(() => handleDisconnect(deviceId));\n\t\t\t\tdisconnectCleanups.set(deviceId, cleanup);\n\t\t\t}\n\n\t\t\temitter.emit(\"connect\", { deviceId, session });\n\t\t} catch (error) {\n\t\t\t// H-003 fix: Log error for debugging reconnection failures\n\t\t\tconsole.warn(\n\t\t\t\t`[web-ble-kit:connection-pool] Reconnection failed for device ${deviceId}:`,\n\t\t\t\terror instanceof Error ? error.message : error,\n\t\t\t);\n\t\t\tadapters.delete(deviceId);\n\t\t} finally {\n\t\t\treconnectingDevices.delete(deviceId);\n\t\t}\n\t}\n\n\treturn {\n\t\tasync connect(\n\t\t\tconnectOptions: BLEConnectOptions = {},\n\t\t): Promise<BLEConnectedSession> {\n\t\t\t// Fix M-001: Check both active sessions and pending connections to prevent race conditions\n\t\t\tif (sessions.size + pendingConnections >= maxConnections) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Maximum connections (${maxConnections}) reached. Disconnect a device before connecting another.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpendingConnections++;\n\t\t\ttry {\n\t\t\t\tconst adapter = createAdapter();\n\t\t\t\tconst session = await adapter.connect(connectOptions);\n\t\t\t\tconst deviceId = session.deviceId;\n\n\t\t\t\t// Store adapter for potential reconnection\n\t\t\t\tadapters.set(deviceId, adapter);\n\t\t\t\tsessions.set(deviceId, session);\n\n\t\t\t\t// Set up disconnect handler\n\t\t\t\tif (session.onDisconnect) {\n\t\t\t\t\tconst cleanup = session.onDisconnect(() =>\n\t\t\t\t\t\thandleDisconnect(deviceId),\n\t\t\t\t\t);\n\t\t\t\t\tdisconnectCleanups.set(deviceId, cleanup);\n\t\t\t\t}\n\n\t\t\t\temitter.emit(\"connect\", { deviceId, session });\n\n\t\t\t\treturn session;\n\t\t\t} finally {\n\t\t\t\tpendingConnections--;\n\t\t\t}\n\t\t},\n\n\t\tgetSession(deviceId: string): BLEConnectedSession | null {\n\t\t\treturn sessions.get(deviceId) ?? null;\n\t\t},\n\n\t\tisConnected(deviceId: string): boolean {\n\t\t\treturn sessions.has(deviceId);\n\t\t},\n\n\t\tasync disconnect(deviceId: string): Promise<void> {\n\t\t\t// Fix F-018: Cancel any pending reconnect for this device\n\t\t\treconnectingDevices.delete(deviceId);\n\n\t\t\tconst session = sessions.get(deviceId);\n\t\t\tif (!session) return;\n\n\t\t\t// Remove from sessions before disconnecting to prevent reconnect attempts\n\t\t\tsessions.delete(deviceId);\n\t\t\tadapters.delete(deviceId);\n\n\t\t\tconst cleanup = disconnectCleanups.get(deviceId);\n\t\t\tif (cleanup) {\n\t\t\t\tcleanup();\n\t\t\t\tdisconnectCleanups.delete(deviceId);\n\t\t\t}\n\n\t\t\tawait session.disconnect();\n\t\t\temitter.emit(\"disconnect\", { deviceId });\n\t\t},\n\n\t\tasync disconnectAll(): Promise<void> {\n\t\t\tconst deviceIds = Array.from(sessions.keys());\n\t\t\tconst results = await Promise.allSettled(\n\t\t\t\tdeviceIds.map((id) => this.disconnect(id)),\n\t\t\t);\n\t\t\tconst failures = results.filter((r) => r.status === \"rejected\");\n\t\t\tif (failures.length > 0) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[web-ble-kit:connection-pool] ${failures.length} disconnect(s) failed`,\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\n\t\tgetSessions(): Map<string, BLEConnectedSession> {\n\t\t\treturn new Map(sessions);\n\t\t},\n\n\t\tget connectionCount(): number {\n\t\t\treturn sessions.size;\n\t\t},\n\n\t\tget maxConnections(): number {\n\t\t\treturn maxConnections;\n\t\t},\n\n\t\tonConnect(\n\t\t\tcallback: (deviceId: string, session: BLEConnectedSession) => void,\n\t\t): () => void {\n\t\t\treturn emitter.on(\"connect\", ({ deviceId, session }) =>\n\t\t\t\tcallback(deviceId, session),\n\t\t\t);\n\t\t},\n\n\t\tonDisconnect(callback: (deviceId: string) => void): () => void {\n\t\t\treturn emitter.on(\"disconnect\", ({ deviceId }) => callback(deviceId));\n\t\t},\n\t};\n}\n", "import { AbortError } from \"../errors/errors\";\n\n/**\n * Options for creating an operation queue.\n */\nexport interface OperationQueueOptions {\n\t/**\n\t * Maximum number of concurrent operations per characteristic.\n\t * @default 1\n\t */\n\tmaxConcurrent?: number;\n\t/**\n\t * AbortSignal to cancel all pending operations.\n\t */\n\tsignal?: AbortSignal;\n}\n\n/**\n * A per-characteristic operation queue that ensures BLE operations\n * are serialized to prevent GATT errors from concurrent access.\n *\n * The Web Bluetooth API does not support concurrent operations on the\n * same characteristic. This queue ensures operations are executed\n * sequentially per characteristic UUID.\n */\nexport interface OperationQueue {\n\t/**\n\t * Enqueues an operation for a specific characteristic.\n\t * The operation will be executed when all previous operations\n\t * for the same characteristic have completed.\n\t *\n\t * @param characteristicUuid - The UUID of the characteristic\n\t * @param operation - The async operation to execute\n\t * @returns Promise resolving to the operation result\n\t * @throws AbortError if the queue's signal is aborted\n\t */\n\tenqueue<T>(\n\t\tcharacteristicUuid: string,\n\t\toperation: () => Promise<T>,\n\t): Promise<T>;\n\n\t/**\n\t * Returns the number of pending operations for a characteristic.\n\t * @param characteristicUuid - The UUID of the characteristic\n\t * @returns Number of pending operations (0 if no queue exists)\n\t */\n\tgetQueueDepth(characteristicUuid: string): number;\n\n\t/**\n\t * Clears all pending operations.\n\t * Operations currently executing will complete, but queued operations\n\t * will be rejected with AbortError.\n\t */\n\tclear(): void;\n}\n\n/**\n * Creates a per-characteristic operation queue for serializing BLE operations.\n *\n * @example Basic usage\n * ```typescript\n * const queue = createOperationQueue();\n *\n * // Operations on the same characteristic are serialized\n * const [result1, result2] = await Promise.all([\n *   queue.enqueue('char-uuid', () => readWithTimeout(char)),\n *   queue.enqueue('char-uuid', () => writeWithTimeout(char, data)),\n * ]);\n * ```\n *\n * @example With abort signal\n * ```typescript\n * const controller = new AbortController();\n * const queue = createOperationQueue({ signal: controller.signal });\n *\n * // Cancel all pending operations\n * controller.abort();\n * ```\n *\n * @param options - Queue configuration options\n * @returns An OperationQueue instance\n */\nexport function createOperationQueue(\n\toptions: OperationQueueOptions = {},\n): OperationQueue {\n\tconst { signal } = options;\n\n\t// Promise chain per characteristic - acts as a mutex\n\tconst queues = new Map<string, Promise<void>>();\n\t// Track queue depth per characteristic\n\tconst queueDepths = new Map<string, number>();\n\t// Track if the queue has been cleared\n\tlet cleared = false;\n\n\tfunction enqueue<T>(\n\t\tcharacteristicUuid: string,\n\t\toperation: () => Promise<T>,\n\t): Promise<T> {\n\t\t// Check abort before queueing\n\t\tif (signal?.aborted) {\n\t\t\treturn Promise.reject(\n\t\t\t\tnew AbortError(signal.reason?.message ?? \"Operation aborted\"),\n\t\t\t);\n\t\t}\n\n\t\tif (cleared) {\n\t\t\treturn Promise.reject(new AbortError(\"Queue has been cleared\"));\n\t\t}\n\n\t\t// Increment queue depth\n\t\tconst currentDepth = queueDepths.get(characteristicUuid) ?? 0;\n\t\tqueueDepths.set(characteristicUuid, currentDepth + 1);\n\n\t\t// Get the current queue tail for this characteristic\n\t\tconst currentQueue = queues.get(characteristicUuid) ?? Promise.resolve();\n\n\t\t// Create a deferred promise for the operation result\n\t\tlet resolveOp: (value: T) => void;\n\t\tlet rejectOp: (error: Error) => void;\n\t\tconst resultPromise = new Promise<T>((resolve, reject) => {\n\t\t\tresolveOp = resolve;\n\t\t\trejectOp = reject;\n\t\t});\n\n\t\t// Chain the new operation onto the queue\n\t\tconst newQueue = currentQueue\n\t\t\t.then(async () => {\n\t\t\t\t// Check abort before executing\n\t\t\t\tif (signal?.aborted) {\n\t\t\t\t\tthrow new AbortError(signal.reason?.message ?? \"Operation aborted\");\n\t\t\t\t}\n\n\t\t\t\tif (cleared) {\n\t\t\t\t\tthrow new AbortError(\"Queue has been cleared\");\n\t\t\t\t}\n\n\t\t\t\treturn operation();\n\t\t\t})\n\t\t\t.then((result) => {\n\t\t\t\tresolveOp?.(result);\n\t\t\t})\n\t\t\t.catch((error: unknown) => {\n\t\t\t\tconst err = error instanceof Error ? error : new Error(String(error));\n\t\t\t\trejectOp?.(err);\n\t\t\t})\n\t\t\t.finally(() => {\n\t\t\t\t// Decrement queue depth\n\t\t\t\tconst depth = queueDepths.get(characteristicUuid) ?? 1;\n\t\t\t\tif (depth <= 1) {\n\t\t\t\t\tqueueDepths.delete(characteristicUuid);\n\t\t\t\t\t// Clean up empty queue\n\t\t\t\t\tif (queues.get(characteristicUuid) === newQueue) {\n\t\t\t\t\t\tqueues.delete(characteristicUuid);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tqueueDepths.set(characteristicUuid, depth - 1);\n\t\t\t\t}\n\t\t\t});\n\n\t\tqueues.set(characteristicUuid, newQueue);\n\n\t\t// Set up abort handler\n\t\tif (signal && !signal.aborted) {\n\t\t\tconst abortHandler = () => {\n\t\t\t\trejectOp?.(\n\t\t\t\t\tnew AbortError(signal.reason?.message ?? \"Operation aborted\"),\n\t\t\t\t);\n\t\t\t};\n\t\t\tsignal.addEventListener(\"abort\", abortHandler, { once: true });\n\n\t\t\t// Clean up abort handler when operation completes\n\t\t\tresultPromise\n\t\t\t\t.finally(() => {\n\t\t\t\t\tsignal.removeEventListener(\"abort\", abortHandler);\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\t// Ignore - just cleaning up\n\t\t\t\t});\n\t\t}\n\n\t\treturn resultPromise;\n\t}\n\n\tfunction getQueueDepth(characteristicUuid: string): number {\n\t\treturn queueDepths.get(characteristicUuid) ?? 0;\n\t}\n\n\tfunction clear(): void {\n\t\tcleared = true;\n\t\tqueues.clear();\n\t\tqueueDepths.clear();\n\t}\n\n\treturn {\n\t\tenqueue,\n\t\tgetQueueDepth,\n\t\tclear,\n\t};\n}\n", "import type { ConnectionState } from \"../types\";\n\nexport type TransitionCallback = (\n\tfrom: ConnectionState,\n\tto: ConnectionState,\n) => void;\n\nexport interface StateMachine {\n\tgetState(): ConnectionState;\n\tcanTransition(to: ConnectionState): boolean;\n\ttransition(to: ConnectionState): void;\n\tonTransition(callback: TransitionCallback): () => void;\n}\n\n/**\n * Valid state transitions:\n * - disconnected -> connecting\n * - connecting -> connected | error | disconnected (cancelled)\n * - connected -> disconnected | error\n * - error -> disconnected | connecting\n */\nconst VALID_TRANSITIONS: Record<ConnectionState, ConnectionState[]> = {\n\tdisconnected: [\"connecting\"],\n\tconnecting: [\"connected\", \"error\", \"disconnected\"],\n\tconnected: [\"disconnected\", \"error\"],\n\terror: [\"disconnected\", \"connecting\"],\n};\n\n/**\n * Creates a new state machine for connection management.\n * @param initialState The initial state (default: 'disconnected')\n */\nexport function createStateMachine(\n\tinitialState: ConnectionState = \"disconnected\",\n): StateMachine {\n\tlet state: ConnectionState = initialState;\n\tconst callbacks = new Set<TransitionCallback>();\n\tlet isTransitioning = false;\n\n\tfunction getState(): ConnectionState {\n\t\treturn state;\n\t}\n\n\tfunction canTransition(to: ConnectionState): boolean {\n\t\tconst validTargets = VALID_TRANSITIONS[state];\n\t\treturn validTargets.includes(to);\n\t}\n\n\tfunction transition(to: ConnectionState): void {\n\t\t// H-005: Re-entrancy guard to prevent infinite transition loops\n\t\tif (isTransitioning) {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot transition while another transition is in progress (attempted ${state} -> ${to})`,\n\t\t\t);\n\t\t}\n\n\t\tif (!canTransition(to)) {\n\t\t\tthrow new Error(`Invalid state transition: ${state} -> ${to}`);\n\t\t}\n\n\t\tconst from = state;\n\t\tstate = to;\n\t\tisTransitioning = true;\n\n\t\ttry {\n\t\t\tfor (const cb of callbacks) {\n\t\t\t\ttry {\n\t\t\t\t\tcb(from, to);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\"[web-ble-kit:state-machine] Transition callback error:\",\n\t\t\t\t\t\te,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tisTransitioning = false;\n\t\t}\n\t}\n\n\tfunction onTransition(callback: TransitionCallback): () => void {\n\t\tcallbacks.add(callback);\n\t\treturn () => {\n\t\t\tcallbacks.delete(callback);\n\t\t};\n\t}\n\n\treturn {\n\t\tgetState,\n\t\tcanTransition,\n\t\ttransition,\n\t\tonTransition,\n\t};\n}\n", "/** Helper to safely read a byte with bounds checking */\nfunction safeReadByte(data: Uint8Array, offset: number): number | undefined {\n\tif (offset < 0 || offset >= data.length) {\n\t\treturn undefined;\n\t}\n\treturn data[offset];\n}\n\nexport function readByte(data: Uint8Array, offset: number): number {\n\tconst value = safeReadByte(data, offset);\n\treturn value ?? 0;\n}\n\nexport function readUint16LE(data: Uint8Array, offset: number): number {\n\tif (offset < 0 || offset + 2 > data.length) {\n\t\treturn 0;\n\t}\n\treturn readByte(data, offset) | (readByte(data, offset + 1) << 8);\n}\n\nexport function readUint24LE(data: Uint8Array, offset: number): number {\n\tif (offset < 0 || offset + 3 > data.length) {\n\t\treturn 0;\n\t}\n\treturn (\n\t\treadByte(data, offset) |\n\t\t(readByte(data, offset + 1) << 8) |\n\t\t(readByte(data, offset + 2) << 16)\n\t);\n}\n\nexport function readUint24BE(data: Uint8Array, offset: number): number {\n\tif (offset < 0 || offset + 3 > data.length) {\n\t\treturn 0;\n\t}\n\treturn (\n\t\t(readByte(data, offset) << 16) |\n\t\t(readByte(data, offset + 1) << 8) |\n\t\treadByte(data, offset + 2)\n\t);\n}\n\n// =============================================================================\n// Checked variants - return undefined for invalid offsets (H-002 fix)\n// =============================================================================\n\n/**\n * Reads a single byte, returning undefined for invalid offsets.\n * Unlike readByte which returns 0, this allows distinguishing between\n * actual zero values and read errors.\n */\nexport function readByteChecked(\n\tdata: Uint8Array,\n\toffset: number,\n): number | undefined {\n\treturn safeReadByte(data, offset);\n}\n\n/**\n * Reads a 16-bit little-endian value, returning undefined for invalid offsets.\n */\nexport function readUint16LEChecked(\n\tdata: Uint8Array,\n\toffset: number,\n): number | undefined {\n\tconst b0 = safeReadByte(data, offset);\n\tconst b1 = safeReadByte(data, offset + 1);\n\tif (b0 === undefined || b1 === undefined) {\n\t\treturn undefined;\n\t}\n\treturn b0 | (b1 << 8);\n}\n\n/**\n * Reads a 24-bit little-endian value, returning undefined for invalid offsets.\n */\nexport function readUint24LEChecked(\n\tdata: Uint8Array,\n\toffset: number,\n): number | undefined {\n\tconst b0 = safeReadByte(data, offset);\n\tconst b1 = safeReadByte(data, offset + 1);\n\tconst b2 = safeReadByte(data, offset + 2);\n\tif (b0 === undefined || b1 === undefined || b2 === undefined) {\n\t\treturn undefined;\n\t}\n\treturn b0 | (b1 << 8) | (b2 << 16);\n}\n\n/**\n * Reads a 24-bit big-endian value, returning undefined for invalid offsets.\n */\nexport function readUint24BEChecked(\n\tdata: Uint8Array,\n\toffset: number,\n): number | undefined {\n\tconst b0 = safeReadByte(data, offset);\n\tconst b1 = safeReadByte(data, offset + 1);\n\tconst b2 = safeReadByte(data, offset + 2);\n\tif (b0 === undefined || b1 === undefined || b2 === undefined) {\n\t\treturn undefined;\n\t}\n\treturn (b0 << 16) | (b1 << 8) | b2;\n}\n", "// Standard protocol (A1, R1, P1)\nexport const STANDARD_PACKET_HEADER_1 = 0xf7;\nexport const STANDARD_PACKET_HEADER_2 = 0xa2;\nexport const STANDARD_PACKET_SUFFIX = 0xfd;\nexport const STANDARD_MIN_STATUS_LENGTH = 16;\nexport const STANDARD_OFFSET_STATE = 2;\nexport const STANDARD_OFFSET_SPEED = 3;\nexport const STANDARD_OFFSET_MODE = 4;\nexport const STANDARD_OFFSET_TIME = 5;\nexport const STANDARD_OFFSET_DISTANCE = 8;\nexport const STANDARD_OFFSET_STEPS = 11;\nexport const STANDARD_CMD_ASK_STATS_BODY = 0x00;\nexport const STANDARD_CMD_START_BODY: readonly number[] = [0x04, 0x01] as const;\nexport const STANDARD_CMD_STOP_BODY: readonly number[] = [0x04, 0x00] as const;\nexport const STANDARD_CMD_SET_SPEED_OP = 0x03;\nexport const STANDARD_DEFAULT_MIN_SPEED_KMH = 0.5;\nexport const STANDARD_DEFAULT_MAX_SPEED_KMH = 6.0;\n/** Standard protocol encodes speed as value * 10 (e.g., 3.5 km/h = 35) */\nexport const STANDARD_SPEED_SCALE = 10;\n/** Standard protocol encodes distance in units of 0.01 km (centimeters to km) */\nexport const STANDARD_DISTANCE_SCALE = 100;\n\n// FTMS protocol (Z1, R2, C2)\nexport const FTMS_OP_REQUEST_CONTROL = 0x00;\nexport const FTMS_OP_SET_TARGET_SPEED = 0x02;\nexport const FTMS_OP_START_RESUME = 0x07;\nexport const FTMS_OP_STOP_PAUSE = 0x08;\nexport const FTMS_STOP_PARAM_STOP = 0x01;\nexport const FTMS_SPEED_SCALE = 100;\nexport const FTMS_METERS_PER_KM = 1000;\nexport const FTMS_DEFAULT_MIN_SPEED_KMH = 0.5;\nexport const FTMS_DEFAULT_MAX_SPEED_KMH = 6.0;\n/** Minimum bytes required: 2 bytes flags */\nexport const FTMS_MIN_PACKET_LENGTH = 2;\n/** Minimum bytes for speed: 2 bytes flags + 2 bytes speed */\nexport const FTMS_MIN_SPEED_LENGTH = 4;\nexport const FTMS_FLAG_AVERAGE_SPEED = 1 << 1;\nexport const FTMS_FLAG_TOTAL_DISTANCE = 1 << 2;\nexport const FTMS_FLAG_INCLINATION = 1 << 3;\nexport const FTMS_FLAG_ELEVATION_GAIN = 1 << 4;\nexport const FTMS_FLAG_INSTANTANEOUS_PACE = 1 << 5;\nexport const FTMS_FLAG_AVERAGE_PACE = 1 << 6;\nexport const FTMS_FLAG_EXPENDED_ENERGY = 1 << 7;\nexport const FTMS_FLAG_HEART_RATE = 1 << 8;\nexport const FTMS_FLAG_METABOLIC_EQUIVALENT = 1 << 9;\nexport const FTMS_FLAG_ELAPSED_TIME = 1 << 10;\n\n// GATT UUIDs\nexport const GATT_FTMS_SERVICE = '1826';\nexport const GATT_FTMS_TREADMILL_DATA = '2acd';\nexport const GATT_FTMS_CONTROL_POINT = '2ad9';\nexport const GATT_STANDARD_SERVICE_FE00 = 'fe00';\nexport const GATT_STANDARD_SERVICE_FFF0 = 'fff0';\nexport const GATT_STANDARD_WRITE_FE01 = 'fe01';\nexport const GATT_STANDARD_WRITE_FFF2 = 'fff2';\nexport const GATT_STANDARD_NOTIFY_FE02 = 'fe02';\nexport const GATT_STANDARD_NOTIFY_FFF1 = 'fff1';\nexport const BLUETOOTH_UUID_BASE = '-0000-1000-8000-00805f9b34fb';\n\nexport function toFullUuid(shortId: number | string): string {\n  const hex =\n    typeof shortId === 'number' ? shortId.toString(16) : shortId.toLowerCase();\n  return `0000${hex.padStart(4, '0')}${BLUETOOTH_UUID_BASE}`;\n}\n\nexport const STORAGE_KEY = 'walkingpad-ble-device-id';\n\n/**\n * Default device name prefixes for WalkingPad treadmills.\n * Used when filtering Bluetooth devices during discovery.\n */\nexport const DEFAULT_NAME_PREFIXES: readonly string[] = [\n  'Walking',\n  'KS',\n] as const;\n\n/**\n * Polling interval for standard protocol devices (A1, R1, P1).\n * 3 seconds balances responsiveness with BLE traffic overhead.\n * Lower values increase battery drain on the treadmill.\n * FTMS devices use notifications and don't need polling.\n */\nexport const MANAGER_POLL_INTERVAL_MS = 3000;\n\n/**\n * Timeout for BLE write operations.\n * BLE writes can hang indefinitely if the device disconnects or becomes\n * unresponsive. 10 seconds is generous enough for slow devices while\n * preventing the app from hanging forever.\n */\nexport const BLE_WRITE_TIMEOUT_MS = 10000;\n\n/**\n * Timeout for starting BLE notifications.\n * Some devices take a while to set up notifications, but if it takes\n * longer than 15 seconds something is wrong.\n */\nexport const BLE_NOTIFICATION_TIMEOUT_MS = 15000;\n\n/**\n * Timeout for GATT connection.\n * Bluetooth connections can hang for 30+ seconds on some devices.\n * 20 seconds gives reasonable time for slow connections while\n * preventing indefinite hangs.\n */\nexport const BLE_CONNECTION_TIMEOUT_MS = 20000;\n", "/**\n * Logger interface for customizable logging.\n * Allows library users to integrate with their own logging infrastructure.\n */\nexport interface Logger {\n  /**\n   * Log debug information for development troubleshooting.\n   * Optional - if not provided, debug messages are silently dropped.\n   */\n  debug?(message: string, ...args: unknown[]): void;\n  warn(message: string, ...args: unknown[]): void;\n  error(message: string, ...args: unknown[]): void;\n}\n\nconst noop = () => {};\n\nconst defaultLogger: Logger = {\n  debug: noop,\n  warn: (msg, ...args) => console.warn(msg, ...args),\n  error: (msg, ...args) => console.error(msg, ...args),\n};\n\nlet currentLogger: Logger = defaultLogger;\n\nexport function getLogger(): Logger {\n  return currentLogger;\n}\n\nexport function setLogger(logger: Logger): void {\n  currentLogger = logger;\n}\n\nexport function resetLogger(): void {\n  currentLogger = defaultLogger;\n}\n\nexport function enableDebugLogging(): void {\n  const current = currentLogger;\n  currentLogger = {\n    ...current,\n    debug: (msg, ...args) => console.debug(msg, ...args),\n  };\n}\n", "/**\n * Re-export common errors from web-ble-kit.\n */\nexport {\n  AbortError,\n  NotConnectedError,\n  raceWithAbort,\n  TimeoutError,\n  withTimeout,\n} from 'web-ble-kit';\n\n/**\n * Error thrown when speed value is outside valid range.\n */\nexport class SpeedOutOfRangeError extends RangeError {\n  constructor(\n    public readonly value: number,\n    public readonly min: number,\n    public readonly max: number,\n  ) {\n    super(`Speed ${value} km/h is out of range [${min}, ${max}]`);\n    this.name = 'SpeedOutOfRangeError';\n  }\n}\n\n/**\n * Normalizes any thrown value into an Error instance.\n * Ensures consistent error handling throughout the codebase.\n */\nexport function normalizeError(e: unknown): Error {\n  if (e instanceof Error) {\n    return e;\n  }\n\n  if (e === null) {\n    return new Error('null');\n  }\n\n  if (e === undefined) {\n    return new Error('undefined');\n  }\n\n  if (typeof e === 'string') {\n    return new Error(e);\n  }\n\n  if (typeof e === 'object') {\n    try {\n      return new Error(JSON.stringify(e));\n    } catch {\n      // Circular reference or other JSON error\n      return new Error(String(e));\n    }\n  }\n\n  return new Error(String(e));\n}\n", "/**\n * Re-export common types from web-ble-kit for convenience.\n */\nexport type {\n  BLEAdapter,\n  BLEConnectedSession,\n  BLEConnectOptions,\n  BLEGATTCharacteristic,\n  BLEGATTService,\n  ConnectionState,\n  DeviceStorage,\n  RequestDeviceFilter,\n} from 'web-ble-kit';\n\nimport type {\n  BLEGATTCharacteristic as BLEGATTCharacteristicType,\n  RequestDeviceFilter as RequestDeviceFilterType,\n} from 'web-ble-kit';\n\ndeclare const DeviceStateBrand: unique symbol;\ndeclare const DeviceModeBrand: unique symbol;\n\n/**\n * Device operational state (branded type for type safety)\n * 0 = idle/standby\n * 1 = running/active\n * 2 = starting (transitional)\n * 3 = paused\n */\nexport type DeviceState = (0 | 1 | 2 | 3) & {\n  readonly [DeviceStateBrand]: never;\n};\n\n/**\n * Device control mode (branded type for type safety)\n * 0 = standby\n * 1 = manual (user controls speed)\n * 2 = auto (speed adjusts based on position on belt)\n */\nexport type DeviceMode = (0 | 1 | 2) & { readonly [DeviceModeBrand]: never };\n\nexport function createDeviceState(n: 0 | 1 | 2 | 3): DeviceState {\n  return n as DeviceState;\n}\n\nexport function createDeviceMode(n: 0 | 1 | 2): DeviceMode {\n  return n as DeviceMode;\n}\n\n/**\n * Clamps a number to a valid DeviceState (0-3).\n * Handles floats by flooring and out-of-range values by clamping.\n * Returns 0 for non-finite values (NaN, Infinity, -Infinity).\n */\nexport function clampDeviceState(n: number): DeviceState {\n  if (!Number.isFinite(n)) return createDeviceState(0);\n  const clamped = Math.min(Math.max(0, Math.floor(n)), 3) as 0 | 1 | 2 | 3;\n  return createDeviceState(clamped);\n}\n\n/**\n * Clamps a number to a valid DeviceMode (0-2).\n * Handles floats by flooring and out-of-range values by clamping.\n * Returns 0 for non-finite values (NaN, Infinity, -Infinity).\n */\nexport function clampDeviceMode(n: number): DeviceMode {\n  if (!Number.isFinite(n)) return createDeviceMode(0);\n  const clamped = Math.min(Math.max(0, Math.floor(n)), 2) as 0 | 1 | 2;\n  return createDeviceMode(clamped);\n}\n\n/**\n * Current state of the WalkingPad treadmill.\n * Received periodically via notifications (FTMS) or polling (standard protocol).\n */\nexport interface WalkingPadState {\n  /** Device operational state (0=idle, 1=running, 2=starting, 3=paused) */\n  state: DeviceState;\n  /** Current speed in km/h */\n  speed: number;\n  /** Elapsed time in seconds */\n  time: number;\n  /** Distance traveled in km */\n  distance: number;\n  /** Step count */\n  steps: number;\n  /** Control mode (0=standby, 1=manual, 2=auto) */\n  mode: DeviceMode;\n  /** Whether the belt is currently moving */\n  isRunning: boolean;\n}\n\n/**\n * Options for connecting to a WalkingPad device.\n */\nexport interface ConnectOptions {\n  /**\n   * Bluetooth device filters. If empty, defaults to known WalkingPad name prefixes.\n   */\n  filters?: RequestDeviceFilterType[];\n  /**\n   * Optional service UUIDs to request access to.\n   * Defaults to FTMS and standard WalkingPad services.\n   */\n  optionalServices?: (number | string)[];\n  /**\n   * If true, stores device ID in localStorage for faster reconnection.\n   * @default false\n   */\n  rememberDevice?: boolean;\n  /**\n   * Polling interval in milliseconds for standard protocol devices.\n   * FTMS devices use notifications and ignore this setting.\n   * @default 3000\n   */\n  pollIntervalMs?: number;\n  /**\n   * AbortSignal to cancel the connection attempt.\n   * When aborted, the connection transitions to 'disconnected' state.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * Options for reconnecting to a previously paired device.\n */\nexport interface ReconnectOptions {\n  /**\n   * AbortSignal to cancel the reconnection attempt.\n   * When aborted, the reconnection transitions to 'disconnected' state.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * Internal session object containing discovered GATT characteristics.\n * Created by the transport layer after successful service discovery.\n */\nexport interface TransportSession {\n  /** UUIDs of all discovered GATT services */\n  serviceUuids: string[];\n\n  /** Characteristic used for writing commands to the device */\n  writeChar: BLEGATTCharacteristicType;\n\n  /** Characteristic used for receiving notifications from the device */\n  notifyChar: BLEGATTCharacteristicType;\n\n  /** FTMS control point characteristic (null for standard protocol) */\n  controlPointChar: BLEGATTCharacteristicType | null;\n\n  /** Disconnects from the device */\n  disconnect(): Promise<void>;\n}\n\n/**\n * Protocol type identifier.\n * - 'standard': Legacy protocol for A1, R1, P1 models (polling-based)\n * - 'ftms': FTMS protocol for Z1, R2, C2 models (notification-based)\n */\nexport type ProtocolName = 'standard' | 'ftms';\n\n/**\n * Protocol implementation interface.\n * Each protocol handles command encoding and response parsing for specific device models.\n *\n * @remarks\n * Implementers must handle:\n * - Command encoding (start, stop, set speed, request control)\n * - Status packet parsing (speed, distance, time, steps)\n * - Protocol-specific byte ordering and scaling factors\n */\nexport interface WalkingPadProtocol {\n  /** The protocol identifier */\n  readonly name: ProtocolName;\n\n  /**\n   * Parses a status packet from the device.\n   * @param data - Raw bytes from the device notification\n   * @returns Parsed treadmill state\n   */\n  parseStatus(data: ArrayBuffer | DataView): WalkingPadState;\n\n  /**\n   * Creates a command to start the treadmill belt.\n   * @returns Encoded command bytes\n   */\n  cmdStart(): Uint8Array;\n\n  /**\n   * Creates a command to stop the treadmill belt.\n   * @returns Encoded command bytes\n   */\n  cmdStop(): Uint8Array;\n\n  /**\n   * Creates a command to request current device status.\n   * Only used by standard protocol (FTMS uses notifications).\n   * @returns Encoded command bytes, or empty array if not supported\n   */\n  cmdAskStats(): Uint8Array;\n\n  /**\n   * Creates a command to set the target speed.\n   * @param kmh - Target speed in km/h (typically 0.5-6.0)\n   * @returns Encoded command bytes\n   * @throws SpeedOutOfRangeError if speed is outside valid range\n   */\n  cmdSetSpeed(kmh: number): Uint8Array;\n\n  /**\n   * Creates a command to request control of the device.\n   * Required by FTMS protocol before sending other commands.\n   * @returns Encoded command bytes, or empty array if not required\n   */\n  cmdRequestControl(): Uint8Array;\n}\n\nexport function createDefaultState(): WalkingPadState {\n  return {\n    state: createDeviceState(0),\n    speed: 0,\n    time: 0,\n    distance: 0,\n    steps: 0,\n    mode: createDeviceMode(0),\n    isRunning: false,\n  };\n}\n\n// Maximum reasonable values for state fields\nconst MAX_SPEED_KMH = 25; // Reasonable max for walking/running treadmill\nconst MAX_TIME_SECONDS = 86400; // 24 hours\nconst MAX_DISTANCE_KM = 100; // Reasonable max for a session\nconst MAX_STEPS = 200000; // Reasonable max for a session\n\n/**\n * Clamps a speed value to a valid range [0, MAX_SPEED_KMH].\n * Returns 0 for non-finite values.\n */\nexport function clampSpeed(value: number): number {\n  if (!Number.isFinite(value)) return 0;\n  return Math.max(0, Math.min(value, MAX_SPEED_KMH));\n}\n\n/**\n * Clamps a time value to a valid range [0, MAX_TIME_SECONDS].\n * Returns 0 for non-finite values.\n */\nexport function clampTime(value: number): number {\n  if (!Number.isFinite(value)) return 0;\n  return Math.max(0, Math.min(Math.floor(value), MAX_TIME_SECONDS));\n}\n\n/**\n * Clamps a distance value to a valid range [0, MAX_DISTANCE_KM].\n * Returns 0 for non-finite values.\n */\nexport function clampDistance(value: number): number {\n  if (!Number.isFinite(value)) return 0;\n  return Math.max(0, Math.min(value, MAX_DISTANCE_KM));\n}\n\n/**\n * Clamps a steps value to a valid range [0, MAX_STEPS].\n * Returns 0 for non-finite values.\n */\nexport function clampSteps(value: number): number {\n  if (!Number.isFinite(value)) return 0;\n  return Math.max(0, Math.min(Math.floor(value), MAX_STEPS));\n}\n", "import { readUint16LE, readUint24LE } from 'web-ble-kit';\nimport {\n  FTMS_DEFAULT_MAX_SPEED_KMH,\n  FTMS_DEFAULT_MIN_SPEED_KMH,\n  FTMS_FLAG_AVERAGE_PACE,\n  FTMS_FLAG_AVERAGE_SPEED,\n  FTMS_FLAG_ELAPSED_TIME,\n  FTMS_FLAG_ELEVATION_GAIN,\n  FTMS_FLAG_EXPENDED_ENERGY,\n  FTMS_FLAG_HEART_RATE,\n  FTMS_FLAG_INCLINATION,\n  FTMS_FLAG_INSTANTANEOUS_PACE,\n  FTMS_FLAG_METABOLIC_EQUIVALENT,\n  FTMS_FLAG_TOTAL_DISTANCE,\n  FTMS_METERS_PER_KM,\n  FTMS_MIN_PACKET_LENGTH,\n  FTMS_MIN_SPEED_LENGTH,\n  FTMS_OP_REQUEST_CONTROL,\n  FTMS_OP_SET_TARGET_SPEED,\n  FTMS_OP_START_RESUME,\n  FTMS_OP_STOP_PAUSE,\n  FTMS_SPEED_SCALE,\n  FTMS_STOP_PARAM_STOP,\n} from './constants';\nimport { SpeedOutOfRangeError } from './errors';\nimport type { WalkingPadProtocol } from './types';\nimport {\n  clampDeviceMode,\n  clampDeviceState,\n  clampDistance,\n  clampSpeed,\n  clampSteps,\n  clampTime,\n  createDefaultState,\n  type ProtocolName,\n  type WalkingPadState,\n} from './types';\n\nexport class FTMSProtocol implements WalkingPadProtocol {\n  readonly name: ProtocolName = 'ftms';\n\n  parseStatus(data: ArrayBuffer | DataView): WalkingPadState {\n    const state = createDefaultState();\n    const bytes =\n      data instanceof DataView\n        ? new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n        : new Uint8Array(data);\n\n    if (bytes.length < FTMS_MIN_PACKET_LENGTH) {\n      return state;\n    }\n\n    const flags = readUint16LE(bytes, 0);\n    let offset = FTMS_MIN_PACKET_LENGTH;\n\n    // Speed is always present after flags (2 bytes, little-endian, in 0.01 km/h units)\n    if (bytes.length >= FTMS_MIN_SPEED_LENGTH) {\n      state.speed = clampSpeed(readUint16LE(bytes, offset) / FTMS_SPEED_SCALE);\n      offset += 2;\n    }\n\n    // Skip optional fields based on flags\n    // If a flag is set but bytes are missing, return early with partial state\n    // to avoid corrupting subsequent field parsing\n    if (flags & FTMS_FLAG_AVERAGE_SPEED) {\n      if (bytes.length < offset + 2) return state;\n      offset += 2;\n    }\n    if (flags & FTMS_FLAG_TOTAL_DISTANCE) {\n      if (bytes.length < offset + 3) return state;\n      const dist = readUint24LE(bytes, offset);\n      state.distance = clampDistance(dist / FTMS_METERS_PER_KM);\n      offset += 3;\n    }\n    if (flags & FTMS_FLAG_INCLINATION) {\n      if (bytes.length < offset + 4) return state;\n      offset += 4;\n    }\n    if (flags & FTMS_FLAG_ELEVATION_GAIN) {\n      if (bytes.length < offset + 2) return state;\n      offset += 2;\n    }\n    if (flags & FTMS_FLAG_INSTANTANEOUS_PACE) {\n      if (bytes.length < offset + 1) return state;\n      offset += 1;\n    }\n    if (flags & FTMS_FLAG_AVERAGE_PACE) {\n      if (bytes.length < offset + 1) return state;\n      offset += 1;\n    }\n    if (flags & FTMS_FLAG_EXPENDED_ENERGY) {\n      if (bytes.length < offset + 5) return state;\n      offset += 5;\n    }\n    if (flags & FTMS_FLAG_HEART_RATE) {\n      if (bytes.length < offset + 1) return state;\n      offset += 1;\n    }\n    if (flags & FTMS_FLAG_METABOLIC_EQUIVALENT) {\n      if (bytes.length < offset + 1) return state;\n      offset += 1;\n    }\n    if (flags & FTMS_FLAG_ELAPSED_TIME) {\n      if (bytes.length < offset + 2) return state;\n      state.time = clampTime(readUint16LE(bytes, offset));\n      offset += 2;\n    }\n\n    // Derive state from speed using type-safe helpers\n    state.state = clampDeviceState(state.speed > 0 ? 1 : 0);\n    state.isRunning = state.speed > 0;\n    // FTMS doesn't provide mode, default to manual (1) when running\n    state.mode = clampDeviceMode(state.speed > 0 ? 1 : 0);\n\n    // Steps field (non-standard WalkingPad extension at end of packet)\n    if (bytes.length >= offset + 2) {\n      state.steps = clampSteps(readUint16LE(bytes, offset));\n    }\n\n    return state;\n  }\n\n  cmdStart(): Uint8Array {\n    return new Uint8Array([FTMS_OP_START_RESUME]);\n  }\n\n  cmdStop(): Uint8Array {\n    return new Uint8Array([FTMS_OP_STOP_PAUSE, FTMS_STOP_PARAM_STOP]);\n  }\n\n  cmdAskStats(): Uint8Array {\n    // FTMS uses notifications, no polling needed\n    return new Uint8Array(0);\n  }\n\n  cmdSetSpeed(kmh: number): Uint8Array {\n    if (\n      !Number.isFinite(kmh) ||\n      kmh < FTMS_DEFAULT_MIN_SPEED_KMH ||\n      kmh > FTMS_DEFAULT_MAX_SPEED_KMH\n    ) {\n      throw new SpeedOutOfRangeError(\n        kmh,\n        FTMS_DEFAULT_MIN_SPEED_KMH,\n        FTMS_DEFAULT_MAX_SPEED_KMH,\n      );\n    }\n    const value = Math.round(kmh * FTMS_SPEED_SCALE);\n    const buf = new ArrayBuffer(3);\n    const view = new DataView(buf);\n    view.setUint8(0, FTMS_OP_SET_TARGET_SPEED);\n    view.setUint16(1, value, true);\n    return new Uint8Array(buf);\n  }\n\n  cmdRequestControl(): Uint8Array {\n    return new Uint8Array([FTMS_OP_REQUEST_CONTROL]);\n  }\n}\n", "import { readByte, readUint24BE } from 'web-ble-kit';\nimport {\n  STANDARD_CMD_ASK_STATS_BODY,\n  STANDARD_CMD_SET_SPEED_OP,\n  STANDARD_CMD_START_BODY,\n  STANDARD_CMD_STOP_BODY,\n  STANDARD_DEFAULT_MAX_SPEED_KMH,\n  STANDARD_DEFAULT_MIN_SPEED_KMH,\n  STANDARD_DISTANCE_SCALE,\n  STANDARD_MIN_STATUS_LENGTH,\n  STANDARD_OFFSET_DISTANCE,\n  STANDARD_OFFSET_MODE,\n  STANDARD_OFFSET_SPEED,\n  STANDARD_OFFSET_STATE,\n  STANDARD_OFFSET_STEPS,\n  STANDARD_OFFSET_TIME,\n  STANDARD_PACKET_HEADER_1,\n  STANDARD_PACKET_HEADER_2,\n  STANDARD_PACKET_SUFFIX,\n  STANDARD_SPEED_SCALE,\n} from './constants';\nimport { SpeedOutOfRangeError } from './errors';\nimport type { WalkingPadProtocol } from './types';\nimport {\n  clampDeviceMode,\n  clampDeviceState,\n  clampDistance,\n  clampSpeed,\n  clampSteps,\n  clampTime,\n  createDefaultState,\n  type ProtocolName,\n  type WalkingPadState,\n} from './types';\n\nconst PACKET_PREFIX = new Uint8Array([\n  STANDARD_PACKET_HEADER_1,\n  STANDARD_PACKET_HEADER_2,\n]);\n\nexport class StandardProtocol implements WalkingPadProtocol {\n  readonly name: ProtocolName = 'standard';\n\n  private createPacket(body: Uint8Array): Uint8Array {\n    const msg = new Uint8Array(PACKET_PREFIX.length + body.length + 2);\n    msg.set(PACKET_PREFIX, 0);\n    msg.set(body, PACKET_PREFIX.length);\n    let sum = 0;\n    for (let i = 1; i < msg.length - 2; i++) {\n      sum += msg[i]!;\n    }\n    msg[msg.length - 2] = sum & 0xff;\n    msg[msg.length - 1] = STANDARD_PACKET_SUFFIX;\n    return msg;\n  }\n\n  parseStatus(data: ArrayBuffer | DataView): WalkingPadState {\n    const state = createDefaultState();\n    const bytes =\n      data instanceof DataView\n        ? new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n        : new Uint8Array(data);\n\n    if (bytes.length < STANDARD_MIN_STATUS_LENGTH) {\n      return state;\n    }\n\n    const rawState = readByte(bytes, STANDARD_OFFSET_STATE);\n    const rawSpeed = readByte(bytes, STANDARD_OFFSET_SPEED);\n    const rawMode = readByte(bytes, STANDARD_OFFSET_MODE);\n\n    state.state = clampDeviceState(rawState);\n    state.speed = clampSpeed(rawSpeed / STANDARD_SPEED_SCALE);\n    state.mode = clampDeviceMode(rawMode);\n    state.time = clampTime(readUint24BE(bytes, STANDARD_OFFSET_TIME));\n    state.distance = clampDistance(\n      readUint24BE(bytes, STANDARD_OFFSET_DISTANCE) / STANDARD_DISTANCE_SCALE,\n    );\n    state.steps = clampSteps(readUint24BE(bytes, STANDARD_OFFSET_STEPS));\n    state.isRunning = state.speed > 0 || state.state === 1;\n    return state;\n  }\n\n  cmdStart(): Uint8Array {\n    return this.createPacket(Uint8Array.from(STANDARD_CMD_START_BODY));\n  }\n\n  cmdStop(): Uint8Array {\n    return this.createPacket(Uint8Array.from(STANDARD_CMD_STOP_BODY));\n  }\n\n  cmdAskStats(): Uint8Array {\n    return this.createPacket(new Uint8Array([STANDARD_CMD_ASK_STATS_BODY]));\n  }\n\n  cmdSetSpeed(kmh: number): Uint8Array {\n    if (\n      !Number.isFinite(kmh) ||\n      kmh < STANDARD_DEFAULT_MIN_SPEED_KMH ||\n      kmh > STANDARD_DEFAULT_MAX_SPEED_KMH\n    ) {\n      throw new SpeedOutOfRangeError(\n        kmh,\n        STANDARD_DEFAULT_MIN_SPEED_KMH,\n        STANDARD_DEFAULT_MAX_SPEED_KMH,\n      );\n    }\n    const value = Math.round(kmh * STANDARD_SPEED_SCALE);\n    return this.createPacket(\n      new Uint8Array([STANDARD_CMD_SET_SPEED_OP, value]),\n    );\n  }\n\n  cmdRequestControl(): Uint8Array {\n    return new Uint8Array(0);\n  }\n}\n", "import { GATT_FTMS_SERVICE } from './constants';\nimport { FTMSProtocol } from './protocol-ftms';\nimport { StandardProtocol } from './protocol-standard';\nimport type { ProtocolName, WalkingPadProtocol } from './types';\n\n/**\n * Checks if a UUID matches the FTMS service.\n * Handles both short (4 hex chars) and full (128-bit) Bluetooth Base UUIDs.\n * Full UUID format: 0000XXXX-0000-1000-8000-00805f9b34fb where XXXX is the short ID.\n */\nfunction isFtmsServiceUuid(uuid: string): boolean {\n  const normalized = uuid.toLowerCase();\n  const shortId = GATT_FTMS_SERVICE.toLowerCase();\n\n  // Direct match for short UUID\n  if (normalized === shortId) {\n    return true;\n  }\n\n  // For full UUIDs, the short ID must appear at position 4-8 (after '0000')\n  // Format: 0000XXXX-0000-1000-8000-00805f9b34fb\n  if (normalized.length === 36 && normalized.charAt(8) === '-') {\n    const extractedShortId = normalized.substring(4, 8);\n    return extractedShortId === shortId;\n  }\n\n  return false;\n}\n\nexport function detectProtocol(serviceUuids: string[]): ProtocolName {\n  for (const uuid of serviceUuids) {\n    if (isFtmsServiceUuid(uuid)) {\n      return 'ftms';\n    }\n  }\n  return 'standard';\n}\n\nconst protocolCache: { standard?: StandardProtocol; ftms?: FTMSProtocol } = {};\n\nexport function getProtocol(name: ProtocolName): WalkingPadProtocol {\n  if (name === 'ftms') {\n    if (!protocolCache.ftms) {\n      protocolCache.ftms = new FTMSProtocol();\n    }\n    return protocolCache.ftms;\n  } else {\n    if (!protocolCache.standard) {\n      protocolCache.standard = new StandardProtocol();\n    }\n    return protocolCache.standard;\n  }\n}\n", "import {\n  type StartNotificationsOptions as BleStartNotificationsOptions,\n  startNotifications as bleStartNotifications,\n  writeWithTimeout as bleWriteWithTimeout,\n} from 'web-ble-kit';\nimport {\n  BLE_NOTIFICATION_TIMEOUT_MS,\n  BLE_WRITE_TIMEOUT_MS,\n  GATT_FTMS_CONTROL_POINT,\n  GATT_FTMS_SERVICE,\n  GATT_FTMS_TREADMILL_DATA,\n  GATT_STANDARD_NOTIFY_FE02,\n  GATT_STANDARD_NOTIFY_FFF1,\n  GATT_STANDARD_SERVICE_FE00,\n  GATT_STANDARD_SERVICE_FFF0,\n  GATT_STANDARD_WRITE_FE01,\n  GATT_STANDARD_WRITE_FFF2,\n} from './constants';\nimport type { Logger } from './logger';\nimport type {\n  BLEConnectedSession,\n  BLEGATTCharacteristic,\n  BLEGATTService,\n  TransportSession,\n} from './types';\n\n/**\n * Checks if a UUID matches a short UUID identifier.\n * Handles both short (4 hex chars) and full (128-bit) Bluetooth Base UUIDs.\n * Full UUID format: 0000XXXX-0000-1000-8000-00805f9b34fb where XXXX is the short ID.\n */\nfunction uuidMatches(uuid: string, shortId: string): boolean {\n  const normalized = uuid.toLowerCase();\n  const shortNormalized = shortId.toLowerCase();\n\n  // Direct match for short UUIDs\n  if (normalized === shortNormalized) {\n    return true;\n  }\n\n  // For full UUIDs, the short ID must appear at position 4-8 (after '0000')\n  // Format: 0000XXXX-0000-1000-8000-00805f9b34fb\n  if (normalized.length === 36 && normalized.charAt(8) === '-') {\n    const extractedShortId = normalized.substring(4, 8);\n    return extractedShortId === shortNormalized;\n  }\n\n  return false;\n}\n\nexport async function discoverWalkingPad(\n  session: BLEConnectedSession,\n): Promise<TransportSession> {\n  const services = await session.getPrimaryServices();\n  const serviceUuids = services.map((s: BLEGATTService) => s.uuid);\n  let writeChar: BLEGATTCharacteristic | null = null;\n  let notifyChar: BLEGATTCharacteristic | null = null;\n  let controlPointChar: BLEGATTCharacteristic | null = null;\n\n  for (const service of services) {\n    const uuid = service.uuid.toLowerCase();\n    const chars = await service.getCharacteristics();\n\n    if (uuidMatches(uuid, GATT_FTMS_SERVICE)) {\n      for (const c of chars) {\n        const cu = c.uuid.toLowerCase();\n        if (uuidMatches(cu, GATT_FTMS_TREADMILL_DATA) && c.properties.notify) {\n          notifyChar = c;\n        }\n        if (uuidMatches(cu, GATT_FTMS_CONTROL_POINT)) {\n          if (c.properties.write || c.properties.writeWithoutResponse) {\n            writeChar = c;\n          }\n          if (c.properties.indicate) {\n            controlPointChar = c;\n          }\n        }\n      }\n    }\n\n    if (\n      (uuidMatches(uuid, GATT_STANDARD_SERVICE_FE00) ||\n        uuidMatches(uuid, GATT_STANDARD_SERVICE_FFF0)) &&\n      (!writeChar || !notifyChar)\n    ) {\n      for (const c of chars) {\n        const cu = c.uuid.toLowerCase();\n        if (\n          (uuidMatches(cu, GATT_STANDARD_WRITE_FE01) ||\n            uuidMatches(cu, GATT_STANDARD_WRITE_FFF2)) &&\n          (c.properties.write || c.properties.writeWithoutResponse)\n        ) {\n          writeChar = c;\n        }\n        if (\n          (uuidMatches(cu, GATT_STANDARD_NOTIFY_FE02) ||\n            uuidMatches(cu, GATT_STANDARD_NOTIFY_FFF1)) &&\n          c.properties.notify\n        ) {\n          notifyChar = c;\n        }\n      }\n    }\n  }\n\n  if (!writeChar || !notifyChar) {\n    await session.disconnect();\n    throw new Error(\n      'Could not find required write and notify characteristics on device',\n    );\n  }\n\n  return {\n    serviceUuids,\n    writeChar,\n    notifyChar,\n    controlPointChar,\n    disconnect: () => session.disconnect(),\n  };\n}\n\n/**\n * Writes data to a characteristic with a timeout.\n * BLE writes can hang indefinitely, so all user-facing write operations\n * should use this to prevent the app from becoming unresponsive.\n * @throws Error if data is empty\n */\nexport async function writeWithTimeout(\n  char: BLEGATTCharacteristic,\n  data: ArrayBuffer | Uint8Array | DataView,\n  timeoutMs: number = BLE_WRITE_TIMEOUT_MS,\n): Promise<void> {\n  await bleWriteWithTimeout(char, data, { timeoutMs });\n}\n\n/**\n * Writes data to the write characteristic.\n * Used for standard protocol commands and polling.\n * Includes timeout to prevent hanging on unresponsive devices.\n */\nexport async function write(\n  session: TransportSession,\n  data: ArrayBuffer | Uint8Array | DataView,\n  timeoutMs: number = BLE_WRITE_TIMEOUT_MS,\n): Promise<void> {\n  await writeWithTimeout(session.writeChar, data, timeoutMs);\n}\n\n/**\n * Writes data to the control point characteristic.\n * For FTMS protocol, control commands (request control, start, stop, set speed)\n * must be sent to the control point, not the regular write characteristic.\n * Falls back to writeChar if no controlPointChar is available.\n * Includes timeout to prevent hanging on unresponsive devices.\n */\nexport async function writeToControlPoint(\n  session: TransportSession,\n  data: ArrayBuffer | Uint8Array | DataView,\n  timeoutMs: number = BLE_WRITE_TIMEOUT_MS,\n): Promise<void> {\n  const char = session.controlPointChar ?? session.writeChar;\n  await writeWithTimeout(char, data, timeoutMs);\n}\n\n/**\n * Options for starting notifications.\n */\nexport interface StartNotificationsOptions {\n  /** Timeout for starting notifications in milliseconds */\n  timeoutMs?: number;\n  /** Logger for error reporting. Falls back to global logger if not provided. */\n  logger?: Logger;\n}\n\n/**\n * Starts notifications on a characteristic with timeout protection.\n * Returns a cleanup function to stop notifications and remove listeners.\n *\n * @param char - The characteristic to start notifications on\n * @param onData - Callback invoked when data is received\n * @param options - Options including timeout and logger\n * @throws TimeoutError if notification setup takes too long\n */\nexport async function startNotifications(\n  char: BLEGATTCharacteristic,\n  onData: (data: ArrayBuffer) => void,\n  options: StartNotificationsOptions | number = {},\n): Promise<() => void> {\n  // Support legacy signature: startNotifications(char, onData, timeoutMs)\n  const opts = typeof options === 'number' ? { timeoutMs: options } : options;\n  const timeoutMs = opts.timeoutMs ?? BLE_NOTIFICATION_TIMEOUT_MS;\n\n  const bleOptions: BleStartNotificationsOptions = {\n    timeoutMs,\n    logPrefix: '[WalkingPadBLE]',\n  };\n\n  return bleStartNotifications(char, onData, bleOptions);\n}\n", "import {\n  AbortError,\n  createEventEmitter,\n  createPollManager,\n  createStateMachine,\n  type PollManager,\n  raceWithAbort,\n  type StateMachine,\n  type TypedEventEmitter,\n  toEventTarget,\n} from 'web-ble-kit';\nimport {\n  BLE_NOTIFICATION_TIMEOUT_MS,\n  BLE_WRITE_TIMEOUT_MS,\n  MANAGER_POLL_INTERVAL_MS,\n} from './constants';\nimport { NotConnectedError, normalizeError } from './errors';\nimport { getLogger, type Logger } from './logger';\nimport { detectProtocol, getProtocol } from './protocol-factory';\nimport * as transport from './transport';\nimport type {\n  BLEAdapter,\n  BLEConnectedSession,\n  ConnectionState,\n  ConnectOptions,\n  ProtocolName,\n  ReconnectOptions,\n  TransportSession,\n  WalkingPadProtocol,\n  WalkingPadState,\n} from './types';\n\n/**\n * Events emitted by the WalkingPad manager.\n */\nexport type WalkingPadEvents = {\n  state: WalkingPadState;\n  error: Error;\n  connectionStateChange: {\n    from: ConnectionState;\n    to: ConnectionState;\n  };\n};\n\n/**\n * Information about the current session.\n * Available after successful connection.\n */\nexport interface SessionInfo {\n  /** The detected protocol ('standard' or 'ftms') */\n  protocol: ProtocolName;\n  /** UUIDs of discovered GATT services */\n  serviceUuids: string[];\n}\n\n/**\n * Manager interface for controlling WalkingPad treadmills over BLE.\n */\nexport interface WalkingPadBLEManager {\n  /**\n   * Connects to a WalkingPad device.\n   * Opens a device selection dialog in the browser.\n   * @param options - Connection options including filters and polling interval\n   * @throws {ConnectionAbortedError} If the connection is aborted via signal\n   */\n  connect(options?: ConnectOptions): Promise<void>;\n\n  /**\n   * Attempts to reconnect to a previously paired device.\n   * Uses Web Bluetooth's getDevices() API to find known devices.\n   * @param options - Reconnection options including abort signal\n   * @returns true if reconnection succeeded, false if no device found\n   * @throws {ConnectionAbortedError} If the reconnection is aborted via signal\n   */\n  reconnect(options?: ReconnectOptions): Promise<boolean>;\n\n  /**\n   * Disconnects from the current device.\n   * Safe to call even when not connected.\n   */\n  disconnect(): Promise<void>;\n\n  /**\n   * Starts the treadmill belt.\n   * @throws {Error} If not connected\n   */\n  start(): Promise<void>;\n\n  /**\n   * Stops the treadmill belt.\n   * @throws {Error} If not connected\n   */\n  stop(): Promise<void>;\n\n  /**\n   * Sets the target speed of the treadmill.\n   * @param kmh - Target speed in kilometers per hour (0.5-6.0)\n   * @throws {SpeedOutOfRangeError} If speed is outside valid range\n   * @throws {Error} If not connected\n   */\n  setSpeed(kmh: number): Promise<void>;\n\n  /**\n   * Returns the current connection state.\n   */\n  getConnectionState(): ConnectionState;\n\n  /**\n   * Returns session info if connected, null otherwise.\n   * Includes detected protocol and discovered service UUIDs.\n   */\n  getSessionInfo(): SessionInfo | null;\n\n  /**\n   * Typed event emitter for state, error, and connection state changes.\n   * @example\n   * ```typescript\n   * manager.events.on('state', (state) => console.log(state.speed));\n   * manager.events.on('error', (error) => console.error(error));\n   * ```\n   */\n  readonly events: TypedEventEmitter<WalkingPadEvents>;\n\n  /**\n   * Returns an EventTarget adapter for browser integration.\n   * Allows using standard addEventListener/removeEventListener.\n   * @example\n   * ```typescript\n   * const target = manager.asEventTarget();\n   * target.addEventListener('state', (e) => console.log(e.detail));\n   * ```\n   */\n  asEventTarget(): EventTarget;\n}\n\n/**\n * Error thrown when a connection attempt is aborted via AbortSignal.\n */\nexport class ConnectionAbortedError extends Error {\n  constructor() {\n    super('Connection aborted');\n    this.name = 'ConnectionAbortedError';\n  }\n}\n\n/**\n * Options for creating a WalkingPad manager.\n */\nexport interface CreateManagerOptions {\n  /**\n   * Custom logger instance. If not provided, uses the global logger.\n   * Use this to isolate logging in tests or provide custom logging infrastructure.\n   */\n  logger?: Logger;\n\n  /**\n   * Timeout for BLE write operations in milliseconds.\n   * BLE writes can hang indefinitely if the device disconnects or becomes unresponsive.\n   * @default 10000 (10 seconds)\n   */\n  writeTimeoutMs?: number;\n\n  /**\n   * Timeout for starting BLE notifications in milliseconds.\n   * Some devices take a while to set up notifications.\n   * @default 15000 (15 seconds)\n   */\n  notificationTimeoutMs?: number;\n\n  /**\n   * Default polling interval for standard protocol devices in milliseconds.\n   * Can be overridden per-connection via ConnectOptions.pollIntervalMs.\n   * FTMS devices use notifications and don't need polling.\n   * @default 3000 (3 seconds)\n   */\n  pollIntervalMs?: number;\n}\n\n/**\n * Creates a new WalkingPad BLE manager with the given adapter.\n *\n * @param adapter - The BLE adapter to use for connections\n * @param options - Optional configuration including custom logger\n * @returns A manager instance for controlling WalkingPad devices\n *\n * @example\n * ```typescript\n * const manager = createManager(createWebBluetoothAdapter());\n * await manager.connect();\n * await manager.start();\n * await manager.setSpeed(3.5);\n * ```\n *\n * @example Custom logger\n * ```typescript\n * const manager = createManager(adapter, {\n *   logger: { warn: console.warn, error: console.error }\n * });\n * ```\n */\nexport function createManager(\n  adapter: BLEAdapter,\n  options: CreateManagerOptions = {},\n): WalkingPadBLEManager {\n  // Use provided logger or fall back to global logger\n  const logger = options.logger ?? getLogger();\n  const writeTimeoutMs = options.writeTimeoutMs ?? BLE_WRITE_TIMEOUT_MS;\n  const notificationTimeoutMs =\n    options.notificationTimeoutMs ?? BLE_NOTIFICATION_TIMEOUT_MS;\n  const defaultPollIntervalMs =\n    options.pollIntervalMs ?? MANAGER_POLL_INTERVAL_MS;\n  const stateMachine: StateMachine = createStateMachine('disconnected');\n  const events = createEventEmitter<WalkingPadEvents>();\n\n  let session: TransportSession | null = null;\n  let protocol: WalkingPadProtocol | null = null;\n  let protocolName: ProtocolName | null = null;\n  let stopNotify: (() => void) | null = null;\n  let stopControlPointNotify: (() => void) | null = null;\n  let stopDisconnectListener: (() => void) | null = null;\n\n  // Configurable polling interval, stored when connect is called\n  let currentPollIntervalMs = defaultPollIntervalMs;\n\n  // Store service UUIDs for getSessionInfo\n  let serviceUuids: string[] = [];\n\n  // Connection mutex to prevent race conditions\n  let connectionLock: Promise<void> = Promise.resolve();\n\n  // Command mutex to prevent race conditions during command execution\n  let commandLock: Promise<void> = Promise.resolve();\n\n  // Cached EventTarget adapter (lazy created)\n  let eventTargetAdapter: EventTarget | null = null;\n\n  function emitError(error: Error): void {\n    if (events.listenerCount('error') === 0) {\n      // No error handlers, log to console\n      logger.error('[WalkingPadBLE] Unhandled error:', error);\n      return;\n    }\n    events.emit('error', error);\n  }\n\n  function emitState(state: WalkingPadState): void {\n    events.emit('state', state);\n  }\n\n  // Context type for the poll manager\n  interface PollContext {\n    session: TransportSession;\n    protocol: WalkingPadProtocol;\n  }\n\n  // Create poll manager using web-ble-kit\n  const pollManager: PollManager<PollContext> = createPollManager<PollContext>(\n    async (ctx: PollContext) => {\n      const cmd = ctx.protocol.cmdAskStats();\n      if (cmd.byteLength === 0) return;\n      await transport.write(ctx.session, cmd, writeTimeoutMs);\n    },\n    {\n      defaultIntervalMs: defaultPollIntervalMs,\n      maxConsecutiveErrors: 3,\n      onError: (e: Error) => emitError(normalizeError(e)),\n    },\n  );\n\n  // Forward state machine transitions to event emitter\n  stateMachine.onTransition((from, to) => {\n    events.emit('connectionStateChange', { from, to });\n  });\n\n  function transitionState(to: ConnectionState): void {\n    if (stateMachine.canTransition(to)) {\n      stateMachine.transition(to);\n    }\n  }\n\n  /**\n   * Cleans up the session resources without changing state.\n   * The caller is responsible for state transitions.\n   */\n  async function cleanupResources(): Promise<void> {\n    pollManager.stop();\n    if (stopNotify) {\n      stopNotify();\n      stopNotify = null;\n    }\n    if (stopControlPointNotify) {\n      stopControlPointNotify();\n      stopControlPointNotify = null;\n    }\n    if (stopDisconnectListener) {\n      stopDisconnectListener();\n      stopDisconnectListener = null;\n    }\n    if (session) {\n      try {\n        await session.disconnect();\n      } catch (e) {\n        emitError(normalizeError(e));\n      }\n      session = null;\n    }\n    protocol = null;\n    protocolName = null;\n    serviceUuids = [];\n  }\n\n  /**\n   * Cleans up session and transitions to disconnected state.\n   */\n  async function cleanupSession(): Promise<void> {\n    await cleanupResources();\n    transitionState('disconnected');\n  }\n\n  async function connectWithSession(\n    connectedSession: BLEConnectedSession,\n    pollIntervalMs: number,\n  ): Promise<void> {\n    // Register disconnect listener if supported\n    if (connectedSession.onDisconnect) {\n      stopDisconnectListener = connectedSession.onDisconnect(() => {\n        if (stateMachine.getState() === 'connected') {\n          logger.warn('[WalkingPadBLE] Device disconnected unexpectedly');\n          void acquireConnectionLock().then(async (releaseLock) => {\n            try {\n              // Re-check state after acquiring lock (may have changed)\n              if (stateMachine.getState() !== 'disconnected') {\n                await cleanupSession();\n              }\n            } finally {\n              releaseLock();\n            }\n          });\n        }\n      });\n    }\n\n    const s = await transport.discoverWalkingPad(connectedSession);\n    session = s;\n    serviceUuids = s.serviceUuids;\n    protocolName = detectProtocol(s.serviceUuids);\n    protocol = getProtocol(protocolName);\n\n    const currentProtocol = protocol;\n    const currentProtocolName = protocolName;\n    const onNotification = (data: ArrayBuffer): void => {\n      if (!currentProtocol) return;\n      emitState(currentProtocol.parseStatus(data));\n    };\n\n    try {\n      stopNotify = await transport.startNotifications(\n        s.notifyChar,\n        onNotification,\n        {\n          timeoutMs: notificationTimeoutMs,\n          logger,\n        },\n      );\n\n      if (\n        s.controlPointChar &&\n        currentProtocol.cmdRequestControl().byteLength > 0\n      ) {\n        stopControlPointNotify = await transport.startNotifications(\n          s.controlPointChar,\n          () => {},\n          {\n            timeoutMs: notificationTimeoutMs,\n            logger,\n          },\n        );\n        // For FTMS, request control goes to the control point\n        if (currentProtocolName === 'ftms') {\n          await transport.writeToControlPoint(\n            s,\n            currentProtocol.cmdRequestControl(),\n            writeTimeoutMs,\n          );\n        } else {\n          await transport.write(\n            s,\n            currentProtocol.cmdRequestControl(),\n            writeTimeoutMs,\n          );\n        }\n      }\n    } catch (err) {\n      // Clean up any partial setup (don't transition state, caller handles it)\n      await cleanupResources();\n      throw err;\n    }\n\n    // Start polling for standard protocol devices (FTMS uses notifications)\n    if (currentProtocolName === 'standard') {\n      pollManager.start(\n        { session: s, protocol: currentProtocol },\n        { intervalMs: pollIntervalMs },\n      );\n    }\n    transitionState('connected');\n  }\n\n  /**\n   * Acquires the connection lock and returns a release function.\n   * This ensures only one connection operation runs at a time.\n   */\n  async function acquireConnectionLock(): Promise<() => void> {\n    const previousLock = connectionLock;\n    let releaseLock: () => void;\n    connectionLock = new Promise<void>((resolve) => {\n      releaseLock = resolve;\n    });\n    await previousLock;\n    return releaseLock!;\n  }\n\n  /**\n   * Acquires the command lock and returns a release function.\n   * This ensures commands are serialized and state doesn't change mid-command.\n   */\n  async function acquireCommandLock(): Promise<() => void> {\n    const previousLock = commandLock;\n    let releaseLock: () => void;\n    commandLock = new Promise<void>((resolve) => {\n      releaseLock = resolve;\n    });\n    await previousLock;\n    return releaseLock!;\n  }\n\n  /**\n   * Checks if the abort signal is aborted and throws if so.\n   */\n  function checkAborted(signal?: AbortSignal): void {\n    if (signal?.aborted) {\n      throw new ConnectionAbortedError();\n    }\n  }\n\n  /**\n   * Races a promise against an abort signal.\n   * If the signal is aborted before the promise settles, rejects with ConnectionAbortedError.\n   */\n  async function withAbortSignal<T>(\n    promise: Promise<T>,\n    signal?: AbortSignal,\n  ): Promise<T> {\n    if (!signal) {\n      return promise;\n    }\n\n    try {\n      return await raceWithAbort(promise, signal);\n    } catch (err) {\n      if (err instanceof AbortError) {\n        throw new ConnectionAbortedError();\n      }\n      throw err;\n    }\n  }\n\n  async function connect(options: ConnectOptions = {}): Promise<void> {\n    const {\n      signal,\n      pollIntervalMs = defaultPollIntervalMs,\n      ...adapterOptions\n    } = options;\n\n    // Validate pollIntervalMs\n    if (!Number.isFinite(pollIntervalMs) || pollIntervalMs <= 0) {\n      throw new RangeError(\n        `pollIntervalMs must be a positive number, got ${pollIntervalMs}`,\n      );\n    }\n\n    // Check abort before acquiring lock\n    checkAborted(signal);\n\n    const releaseLock = await acquireConnectionLock();\n\n    try {\n      // Check abort after acquiring lock\n      checkAborted(signal);\n\n      const currentState = stateMachine.getState();\n      if (currentState === 'connected' || currentState === 'connecting') {\n        await cleanupSession();\n      }\n      transitionState('connecting');\n\n      // Store polling interval for this connection\n      currentPollIntervalMs = pollIntervalMs;\n\n      try {\n        // Race adapter.connect() against abort signal\n        // This ensures abort immediately rejects even if adapter is slow\n        const connectedSession = await withAbortSignal(\n          adapter.connect(adapterOptions),\n          signal,\n        );\n\n        // Check abort after adapter returns (in case abort fired at exact moment)\n        checkAborted(signal);\n\n        await withAbortSignal(\n          connectWithSession(connectedSession, pollIntervalMs),\n          signal,\n        );\n      } catch (err) {\n        await cleanupResources();\n        if (err instanceof ConnectionAbortedError) {\n          transitionState('disconnected');\n          throw err;\n        } else {\n          transitionState('error');\n          // Normalize error for consistent error types\n          throw normalizeError(err);\n        }\n      }\n    } finally {\n      releaseLock();\n    }\n  }\n\n  async function reconnect(options: ReconnectOptions = {}): Promise<boolean> {\n    const { signal } = options;\n\n    // Check abort before acquiring lock\n    checkAborted(signal);\n\n    const releaseLock = await acquireConnectionLock();\n\n    try {\n      // Check abort after acquiring lock\n      checkAborted(signal);\n\n      const currentState = stateMachine.getState();\n      if (currentState === 'connected' || currentState === 'connecting')\n        return true;\n      if (!adapter.reconnect) return false;\n      transitionState('connecting');\n      try {\n        // Race adapter.reconnect() against abort signal\n        const connectedSession = await withAbortSignal(\n          adapter.reconnect(),\n          signal,\n        );\n\n        // Check abort after adapter returns\n        checkAborted(signal);\n\n        if (!connectedSession) {\n          transitionState('disconnected');\n          return false;\n        }\n\n        await withAbortSignal(\n          connectWithSession(connectedSession, currentPollIntervalMs),\n          signal,\n        );\n        return true;\n      } catch (err) {\n        await cleanupResources();\n        const normalizedErr =\n          err instanceof ConnectionAbortedError ? err : normalizeError(err);\n        if (normalizedErr instanceof ConnectionAbortedError) {\n          transitionState('disconnected');\n          throw normalizedErr;\n        } else {\n          transitionState('error');\n          emitError(normalizedErr);\n          throw normalizedErr;\n        }\n      }\n    } finally {\n      releaseLock();\n    }\n  }\n\n  async function disconnect(): Promise<void> {\n    const releaseLock = await acquireConnectionLock();\n\n    try {\n      if (stateMachine.getState() === 'disconnected') return;\n      await cleanupSession();\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Sends a command using the appropriate characteristic for the protocol.\n   * FTMS commands go to the control point, standard protocol uses regular write.\n   */\n  async function sendCommand(\n    currentSession: TransportSession,\n    currentProtocol: WalkingPadProtocol,\n    currentProtocolName: ProtocolName,\n    getPayload: (p: WalkingPadProtocol) => Uint8Array,\n  ): Promise<void> {\n    const cmd = getPayload(currentProtocol);\n    if (cmd.byteLength === 0) return;\n\n    // FTMS protocol commands must go to the control point characteristic\n    if (currentProtocolName === 'ftms' && currentSession.controlPointChar) {\n      await transport.writeToControlPoint(currentSession, cmd, writeTimeoutMs);\n    } else {\n      await transport.write(currentSession, cmd, writeTimeoutMs);\n    }\n  }\n\n  async function ensureConnectedAndSend(\n    getPayload: (p: WalkingPadProtocol) => Uint8Array,\n  ): Promise<void> {\n    const releaseCommandLock = await acquireCommandLock();\n\n    try {\n      // Validate state and capture references under lock\n      if (\n        stateMachine.getState() !== 'connected' ||\n        !session ||\n        !protocol ||\n        !protocolName\n      ) {\n        throw new NotConnectedError();\n      }\n\n      // Capture references to prevent race conditions\n      const currentSession = session;\n      const currentProtocol = protocol;\n      const currentProtocolName = protocolName;\n\n      await sendCommand(\n        currentSession,\n        currentProtocol,\n        currentProtocolName,\n        getPayload,\n      );\n\n      // Verify state hasn't changed during command execution\n      if (stateMachine.getState() !== 'connected') {\n        throw new NotConnectedError();\n      }\n    } finally {\n      releaseCommandLock();\n    }\n  }\n\n  async function start(): Promise<void> {\n    await ensureConnectedAndSend((p) => p.cmdStart());\n  }\n\n  async function stop(): Promise<void> {\n    await ensureConnectedAndSend((p) => p.cmdStop());\n  }\n\n  async function setSpeed(kmh: number): Promise<void> {\n    await ensureConnectedAndSend((p) => p.cmdSetSpeed(kmh));\n  }\n\n  function getConnectionState(): ConnectionState {\n    return stateMachine.getState();\n  }\n\n  function getSessionInfo(): SessionInfo | null {\n    if (!protocolName || stateMachine.getState() !== 'connected') {\n      return null;\n    }\n    return {\n      protocol: protocolName,\n      serviceUuids: [...serviceUuids],\n    };\n  }\n\n  function asEventTarget(): EventTarget {\n    if (!eventTargetAdapter) {\n      eventTargetAdapter = toEventTarget(events);\n    }\n    return eventTargetAdapter;\n  }\n\n  return {\n    connect,\n    reconnect,\n    disconnect,\n    start,\n    stop,\n    setSpeed,\n    getConnectionState,\n    getSessionInfo,\n    events,\n    asEventTarget,\n  };\n}\n", "/**\n * Creates a throttled version of an async function.\n * Ensures the function is not called more than once per `intervalMs`.\n * If called while throttled, the latest call is queued and executed after the interval.\n *\n * @param fn - The async function to throttle\n * @param intervalMs - Minimum interval between calls in milliseconds\n * @returns A throttled version of the function\n */\nexport function throttleAsync<\n  T extends (...args: Parameters<T>) => Promise<void>,\n>(fn: T, intervalMs: number): T {\n  let lastCallTime = 0;\n  let pendingCall: {\n    args: Parameters<T>;\n    resolve: () => void;\n    reject: (e: Error) => void;\n  } | null = null;\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  const throttled = async (...args: Parameters<T>): Promise<void> => {\n    const now = Date.now();\n    const timeSinceLastCall = now - lastCallTime;\n\n    if (timeSinceLastCall >= intervalMs) {\n      lastCallTime = now;\n      return fn(...args);\n    }\n\n    if (pendingCall) {\n      pendingCall.reject(new Error('Superseded by newer call'));\n    }\n\n    return new Promise<void>((resolve, reject) => {\n      pendingCall = { args, resolve, reject };\n\n      if (!timeoutId) {\n        const delay = intervalMs - timeSinceLastCall;\n        timeoutId = setTimeout(() => {\n          timeoutId = null;\n          if (pendingCall) {\n            const {\n              args: pendingArgs,\n              resolve: pendingResolve,\n              reject: pendingReject,\n            } = pendingCall;\n            pendingCall = null;\n            lastCallTime = Date.now();\n            fn(...pendingArgs)\n              .then(pendingResolve)\n              .catch(pendingReject);\n          }\n        }, delay);\n      }\n    });\n  };\n\n  return throttled as T;\n}\n\n/**\n * Options for creating a throttled setSpeed function.\n */\nexport interface ThrottledSetSpeedOptions {\n  /**\n   * Minimum interval between setSpeed calls in milliseconds.\n   * @default 100\n   */\n  intervalMs?: number;\n}\n\n/**\n * Creates a throttled version of a setSpeed function.\n * Useful for UI sliders that fire rapidly.\n *\n * @param setSpeed - The original setSpeed function\n * @param options - Throttling options\n * @returns A throttled setSpeed function\n *\n * @example\n * ```typescript\n * const throttledSetSpeed = createThrottledSetSpeed(\n *   (kmh) => manager.setSpeed(kmh),\n *   { intervalMs: 100 }\n * );\n *\n * // Safe to call rapidly from a slider\n * slider.oninput = (e) => {\n *   throttledSetSpeed(parseFloat(e.target.value));\n * };\n * ```\n */\nexport function createThrottledSetSpeed(\n  setSpeed: (kmh: number) => Promise<void>,\n  options: ThrottledSetSpeedOptions = {},\n): (kmh: number) => Promise<void> {\n  const { intervalMs = 100 } = options;\n  return throttleAsync(setSpeed, intervalMs);\n}\n"],
  "mappings": "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",
  "names": ["original", "require_retry", "BLUETOOTH_UUID_BASE", "toFullUuid", "writeWithTimeout", "startNotifications", "startNotifications", "options", "toFullUuid"]
}
